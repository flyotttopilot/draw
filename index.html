<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Cabinetry Visualizer Tool</title>

<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<style>
  /* --- 1. RESET & BASIC SETUP --- */
  * { box-sizing: border-box; }
  body { margin: 0; padding: 0; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #ffffff; overflow: hidden; overscroll-behavior: none; }

  /* --- 2. LAYOUT CONTAINER --- */
  #root {
      width: 100vw;              
      height: 100vh;             
      display: flex;
  }

  /* --- 3. SIDEBAR STYLES --- */
  .sidebar {
      background: #f8f9fa;
      border-right: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      transition: width 0.3s ease, min-width 0.3s ease;
      overflow: hidden;
      z-index: 20;
  }
  
  .sidebar.open { width: 350px; min-width: 350px; }
  .sidebar.closed { width: 0; min-width: 0; border-right: none; }

  /* Mobile Top Bar for Back Button + Input */
  .sidebar-mobile-nav {
      background: #1a252f; 
      padding: 10px 15px;
      display: none; /* Hidden by default on Desktop */
      flex-shrink: 0;
      flex-direction: column;
      gap: 10px;
      border-bottom: 1px solid #34495e;
  }
  
  .sidebar-back-btn {
      width: 100%;
      background: #34495e;
      border: 1px solid #46627f;
      color: white;
      padding: 12px;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 10px;
  }
  .sidebar-back-btn:active { background: #2c3e50; }

  /* Styling for the input inside the sidebar */
  .sidebar-input-group {
      display: flex;
      gap: 8px;
  }
  .sidebar-input-group input {
      flex: 1;
      padding: 10px;
      border-radius: 4px;
      border: none;
      background: #fff;
      font-size: 16px;
      outline: none;
      color: #333;
  }
  .sidebar-input-group button {
      padding: 0 15px;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 4px;
      font-weight: 600;
      cursor: pointer;
  }

  .sidebar-header {
      padding: 20px 15px;
      background: #2c3e50;
      color: white;
      font-size: 18px;
      font-weight: bold;
      flex-shrink: 0;
  }

  .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      -webkit-overflow-scrolling: touch; 
  }

  .wall-group { margin-bottom: 25px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
  .wall-title { font-size: 20px; font-weight: 700; color: #333; margin-bottom: 12px; display: flex; align-items: center; gap: 10px; }
  .wall-badge { background: #2563eb; color: white; padding: 4px 10px; border-radius: 6px; font-size: 16px; }
  .cat-title { font-size: 14px; text-transform: uppercase; color: #888; font-weight: 700; margin: 12px 0 6px 0; letter-spacing: 0.5px; }
  
  .cab-item { 
      font-size: 16px; 
      padding: 12px 14px; 
      background: white; 
      border: 1px solid #ddd; 
      margin-bottom: 8px; 
      border-radius: 8px; 
      display: flex; 
      justify-content: space-between; 
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
  }
  .cab-idx { font-weight: bold; color: green; margin-right: 12px; }

  /* --- 4. VISUALIZER CONTAINER --- */
  #kitchen-app-container { 
      flex: 1;
      display: flex; 
      flex-direction: column; 
      height: 100%; 
      background-color: #ffffff; 
      min-width: 0;
  }

  /* --- CONTROLS AREA --- */
  .control-panel {
      flex: 0 0 auto;
      background: #ffffff;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      flex-direction: column;
      z-index: 10;
  }

  .input-row {
      padding: 12px 16px;
      display: flex;
      gap: 12px;
      align-items: center;
  }
  .input-row.primary { background: #f0f7ff; border-bottom: 1px solid #eef2f6; padding: 15px 16px; }
  .input-label { font-size: 14px; font-weight: 600; color: #555; white-space: nowrap; }

  .control-panel input { 
      flex: 1; 
      padding: 12px; 
      border: 1px solid #d1d5db; 
      border-radius: 6px; 
      font-family: 'Consolas', 'Monaco', monospace; 
      font-size: 16px; 
      color: #374151; 
      outline: none; 
  }
  
  .control-panel button { 
      padding: 10px 20px; 
      background-color: #2563eb; 
      color: white; 
      border: none; 
      border-radius: 6px; 
      font-weight: 600; 
      font-size: 14px; 
      cursor: pointer; 
      white-space: nowrap;
      height: 44px; 
  }
  
  .control-panel button.secondary { background-color: #6b7280; }
  
  .control-panel button.toggle-sidebar { 
      background-color: #2c3e50; 
      display: flex; 
      align-items: center; 
      gap: 8px; 
      font-size: 16px;
      padding: 10px 24px;
  }

  /* --- VIEWPORT --- */
  .viewport { 
      flex: 1 1 auto; 
      position: relative; 
      background-color: #ffffff; 
      cursor: grab; 
      overflow: hidden; 
      background-image: radial-gradient(circle, #e5e7eb 1px, transparent 1px); 
      background-size: 20px 20px;
      touch-action: none; 
  }
  .viewport:active { cursor: grabbing; }
  
  svg { width: 100%; height: 100%; display: block; touch-action: none; }
  
  .status-overlay { 
      position: absolute; 
      bottom: 12px; 
      left: 12px; 
      background: rgba(255, 255, 255, 0.9); 
      border: 1px solid #e5e7eb; 
      padding: 6px 10px; 
      border-radius: 4px; 
      font-size: 12px; 
      color: #6b7280; 
      pointer-events: none; 
  }
  
  /* Mobile adjustments */
  @media (max-width: 600px) {
      .input-label { display: none; } 
      .sidebar.open { width: 100%; min-width: 100%; position: absolute; height: 100%; z-index: 999; }
      /* FORCE FLEX DISPLAY ON MOBILE */
      .sidebar-mobile-nav { display: flex !important; } 
      .control-panel button.toggle-sidebar { width: 100%; justify-content: center; }
  }
</style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
  // --- 1. MATH HELPERS ---
  const Vec = {
    add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
    sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
    scale: (a, s) => ({ x: a.x * s, y: a.y * s }),
    dot: (a, b) => a.x * b.x + a.y * b.y,
    dist: (a, b) => Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2),
    len: (a) => Math.sqrt(a.x**2 + a.y**2),
    norm: (a) => { const l = Math.sqrt(a.x**2 + a.y**2); return l < 1e-9 ? {x:0,y:0} : {x:a.x/l, y:a.y/l}; },
    mid: (a, b) => ({ x: (a.x + b.x)/2, y: (a.y + b.y)/2 }),
  };

  const formatDim = (v) => {
    if (v < 0.1) return '0"';
    const sixteenths = Math.round(v * 16);
    const inch = Math.floor(sixteenths / 16);
    const rem = Math.round(sixteenths % 16);
    if (rem === 0) return `${inch}"`;
    let n = rem, d = 16;
    while (n % 2 === 0) { n/=2; d/=2; }
    return inch === 0 ? `${n}/${d}"` : `${inch} ${n}/${d}"`;
  };

  // --- 2. KITCHEN VISUALIZER COMPONENT ---
  const KitchenVisualizer = ({ code, setCode }) => {
    const { useState, useRef, useMemo, useEffect } = React;
    const [viewBox, setViewBox] = useState({ x: -150, y: -150, width: 300, height: 300 });
    const [sidebarOpen, setSidebarOpen] = useState(false); 
    const [description, setDescription] = useState("");
    
    useEffect(() => {
        if (window.innerWidth > 600) setSidebarOpen(true);
    }, []);

    const isDragging = useRef(false);
    const lastPos = useRef({ x: 0, y: 0 });
    const svgRef = useRef(null);
    const dynamicFontSize = viewBox.width / 50; 
    const dynamicStroke = viewBox.width / 700; 

    // --- PARSE DATA FOR LIST VIEW ---
    const organizedData = useMemo(() => {
        const walls = {};
        if (!code) return walls;
        const items = code.replace(/;/g, '\n').split('\n').map((l, i) => {
            const p = l.trim().split('|');
            if (p.length < 2) return null;
            const c = p[1].toUpperCase();
            const isUpper = (c.startsWith('W') || c.includes('WALL FILLER') || c.startsWith('DCW'));
            return { wall: p[0], code: p[1], idx: i + 1, type: isUpper ? 'upper' : 'base' };
        }).filter(Boolean);
        items.forEach(item => {
            if (!walls[item.wall]) walls[item.wall] = { base: [], upper: [] };
            if (item.type === 'base') walls[item.wall].base.push(item);
            else walls[item.wall].upper.push(item);
        });
        return Object.keys(walls).sort().reduce((obj, key) => { obj[key] = walls[key]; return obj; }, {});
    }, [code]);

    // --- GEOMETRY PROCESSING ---
    const { geometry, dimLines, wallLines } = useMemo(() => {
      const items = code.replace(/;/g, '\n').split('\n').map(l => {
        const p = l.trim().split('|');
        if (p.length < 8) return null;
        return { 
          wall: p[0], code: p[1], 
          x1: parseFloat(p[2]), y1: -parseFloat(p[3]), 
          x2: parseFloat(p[5]), y2: -parseFloat(p[6]) 
        };
      }).filter(Boolean);
      
      const geo = []; 
      const allSegments = [];

      items.forEach((item, idx) => {
        const c = item.code.toUpperCase();
        let depth = 24, stroke = 'black', type = 'std', isUpper = false;
        if (c.startsWith('W') || c.includes('WALL FILLER')) { depth = 12; stroke = 'red'; isUpper = true; }
        else if (c.startsWith('DCW')) { depth = 12; stroke = 'red'; type = 'diag'; isUpper = true; }
        else if (c.startsWith('ERB')) { depth = 24; stroke = 'black'; type = 'L'; }
        
        const P1 = {x: item.x1, y: item.y1}, P2 = {x: item.x2, y: item.y2};
        const vec = Vec.sub(P2, P1);
        if (Vec.len(vec) < 0.1) return;
        const u = Vec.norm(vec); const roomVec = { x: -u.y, y: u.x }; 
        let verts = [], labelPos = {x:0, y:0};
        
        const resolveBackDir = (uSeg, bisector) => { const n1 = { x: -uSeg.y, y: uSeg.x }; const n2 = { x: uSeg.y, y: -uSeg.x }; return Vec.dot(n1, bisector) < 0 ? n1 : n2; };
        const addSeg = (s, e, normal) => { allSegments.push({ start: s, end: e, normal, isUpper, wallRef: item.wall }); };
        
        if (type === 'std') {
           const F1 = Vec.add(P1, Vec.scale(roomVec, depth)); const F2 = Vec.add(P2, Vec.scale(roomVec, depth));
           verts = [P1, P2, F2, F1]; const labelShift = isUpper ? 0.5 : 0.9;
           labelPos = Vec.add(Vec.mid(P1, P2), Vec.scale(roomVec, depth * labelShift)); addSeg(P1, P2, Vec.scale(roomVec, -1));
        } else if (type === 'L' || type === 'diag') {
           const C1 = {x:P1.x, y:P2.y}, C2 = {x:P2.x, y:P1.y}; const cross = (P2.x-P1.x)*(C1.y-P2.y) - (P2.y-P1.y)*(C1.x-P2.x); const C = cross < 0 ? C1 : C2;
           const u1 = Vec.norm(Vec.sub(P1, C)), u2 = Vec.norm(Vec.sub(P2, C)); const bisector = Vec.norm(Vec.add(u1, u2));
           const F1 = Vec.add(P1, Vec.scale(u2, depth)), F2 = Vec.add(P2, Vec.scale(u1, depth));
           if(type === 'L') { const Inner = Vec.add(C, Vec.add(Vec.scale(u1, depth), Vec.scale(u2, depth))); verts = [P1, C, P2, F2, Inner, F1]; } 
           else { verts = [P1, C, P2, F2, F1]; }
           const labelShift = isUpper ? 0.8 : 1.4; labelPos = Vec.add(C, Vec.scale(bisector, depth * labelShift));
           const dir1 = Vec.scale(u1, -1); const wallNormal1 = resolveBackDir(dir1, bisector); addSeg(C, P1, wallNormal1);
           const dir2 = Vec.scale(u2, -1); const wallNormal2 = resolveBackDir(dir2, bisector); addSeg(C, P2, wallNormal2);
        }
        geo.push({ id: idx, verts, labelPos, code: item.code, stroke, idx: idx+1 });
      });

      // --- FIXED WALL GROUPING LOGIC ---
      // Instead of grouping by geometry (which might merge Wall A and B if aligned),
      // we group strictly by the 'wallRef' string ("A", "B", etc.)
      const wallGroups = {};
      allSegments.forEach(seg => {
          // If we haven't seen this wall letter yet, initialize it
          if (!wallGroups[seg.wallRef]) {
              wallGroups[seg.wallRef] = { normal: seg.normal, segments: [] };
          }
          // We assume all segments with the same Wall Letter share a normal
          // (or we just take the first one found, which works for 2D cabinet strips)
          wallGroups[seg.wallRef].segments.push(seg);
      });

      const dims = []; 
      const walls = [];

      // Iterate over each named wall (A, B, C...)
      Object.keys(wallGroups).forEach(key => {
          const wall = wallGroups[key];
          // Recalculate robust normal from the first segment
          const normal = Vec.norm(wall.segments[0].normal);
          
          const axis = { x: -normal.y, y: normal.x }; 
          const proj = p => Vec.dot(p, axis);
          let minT = Infinity, maxT = -Infinity, pStart = null, pEnd = null;

          wall.segments.forEach(s => { 
             [s.start, s.end].forEach(p => { 
                 const t = proj(p); 
                 if(t < minT) { minT = t; pStart = p; } 
                 if(t > maxT) { maxT = t; pEnd = p; } 
             }); 
          });

          if(pStart && pEnd && Vec.dist(pStart, pEnd) > 1.0) { 
              walls.push({ p1: pStart, p2: pEnd }); 
              // Explicitly use 'key' (A, B, C...) as the label
              dims.push({ p1: pStart, p2: pEnd, offset: 22, color: 'blue', text: formatDim(Vec.dist(pStart, pEnd)), normal: normal, label: key }); 
          }

          const makeChain = (isUp, color, offset) => {
             const chainSegs = wall.segments.filter(s => s.isUpper === isUp); if (!chainSegs.length) return;
             const items = chainSegs.map(s => { const t1 = proj(s.start), t2 = proj(s.end); return { min: Math.min(t1,t2), max: Math.max(t1,t2), p_min: t1<t2?s.start:s.end, p_max: t1<t2?s.end:s.start }; });
             items.sort((a,b) => a.min - b.min);
             if (pStart) { const startGap = Vec.dist(pStart, items[0].p_min); if (startGap > 0.5) dims.push({ p1: pStart, p2: items[0].p_min, offset, color, text: formatDim(startGap), normal: normal, isGap: true }); }
             for(let i=0; i<items.length; i++) {
                 const curr = items[i]; dims.push({ p1: curr.p_min, p2: curr.p_max, offset, color, text: formatDim(Vec.dist(curr.p_min, curr.p_max)), normal: normal });
                 if(i < items.length-1) { const next = items[i+1]; const gap = Vec.dist(curr.p_max, next.p_min); if(gap > 0.5) dims.push({ p1: curr.p_max, p2: next.p_min, offset, color, text: formatDim(gap), normal: normal, isGap: true }); }
             }
             if (pEnd) { const endGap = Vec.dist(items[items.length-1].p_max, pEnd); if (endGap > 0.5) dims.push({ p1: items[items.length-1].p_max, p2: pEnd, offset, color, text: formatDim(endGap), normal: normal, isGap: true }); }
          };
          makeChain(true, 'red', 10); makeChain(false, 'black', 16);
      });
      return { geometry: geo, dimLines: dims, wallLines: walls };
    }, [code]);

    // --- INTERACTION ---
    useEffect(() => {
        if (!geometry.length) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        geometry.forEach(g => { g.verts.forEach(v => { if (v.x < minX) minX = v.x; if (v.x > maxX) maxX = v.x; if (v.y < minY) minY = v.y; if (v.y > maxY) maxY = v.y; }); });
        const w = maxX - minX; const h = maxY - minY; if (w === 0 || h === 0) return;
        const padding = Math.max(w, h) * 0.25; setViewBox({ x: minX - padding, y: minY - padding, width: w + (padding * 2), height: h + (padding * 2) });
    }, [geometry]);

    const handleWheel = (e) => { e.preventDefault(); const s = e.deltaY > 0 ? 1.1 : 0.9; setViewBox(v => ({ x: v.x-(v.width*(s-1))/2, y: v.y-(v.height*(s-1))/2, width: v.width*s, height: v.height*s })); };
    const handleStart = (x, y) => { isDragging.current = true; lastPos.current = { x, y }; };
    const handleEnd = () => { isDragging.current = false; };
    const handleMove = (x, y) => { if (!isDragging.current) return; const r = svgRef.current.getBoundingClientRect(); const scaleX = viewBox.width / r.width; const scaleY = viewBox.height / r.height; const dx = (x - lastPos.current.x) * scaleX; const dy = (y - lastPos.current.y) * scaleY; setViewBox(v => ({...v, x: v.x - dx, y: v.y - dy})); lastPos.current = { x, y }; };

    return (
      <>
      <div className={`sidebar ${sidebarOpen ? 'open' : 'closed'}`}>
         {/* NEW: Dedicated Mobile Nav Bar with Input */}
         <div className="sidebar-mobile-nav">
            <button className="sidebar-back-btn" onClick={() => setSidebarOpen(false)}>◀ Back to Drawing</button>
            <div className="sidebar-input-group">
                <input 
                    value={description} 
                    onChange={e => setDescription(e.target.value)}
                    placeholder="Describe Kitchen..." 
                />
                <button>Go</button>
            </div>
         </div>
         
         <div className="sidebar-header">Cabinet List</div>
         
         <div className="sidebar-content">
            {Object.keys(organizedData).map(wallKey => (
                <div key={wallKey} className="wall-group">
                    <div className="wall-title">
                        <span className="wall-badge">Wall {wallKey}</span>
                    </div>
                    {organizedData[wallKey].base.length > 0 && (
                        <>
                            <div className="cat-title">Base Cabinets</div>
                            {organizedData[wallKey].base.map((item, i) => (
                                <div key={i} className="cab-item">
                                    <span><span className="cab-idx">({item.idx})</span> {item.code}</span>
                                </div>
                            ))}
                        </>
                    )}
                    {organizedData[wallKey].upper.length > 0 && (
                        <>
                            <div className="cat-title">Wall Cabinets</div>
                            {organizedData[wallKey].upper.map((item, i) => (
                                <div key={i} className="cab-item">
                                    <span><span className="cab-idx">({item.idx})</span> {item.code}</span>
                                </div>
                            ))}
                        </>
                    )}
                </div>
            ))}
         </div>
      </div>

      <div id="kitchen-app-container">
        <div className="control-panel">
          <div className="input-row primary">
             {/* Unified Toggle Button */}
             <button className="toggle-sidebar" onClick={() => setSidebarOpen(!sidebarOpen)} title="Toggle List View">
                {sidebarOpen ? '◀' : '☰ List View'}
             </button>
             
             <div className="input-label">Describe Kitchen:</div>
             <input value={description} onChange={e => setDescription(e.target.value)} />
             <button>Generate</button>
          </div>
          
          <div className="input-row">
             <div className="input-label">Kitchen Code:</div>
             <input value={code} onChange={e => setCode(e.target.value)} />
             <button onClick={() => setCode('')} className="secondary">Clear</button>
          </div>
        </div>

        <div className="viewport">
          <svg ref={svgRef} viewBox={`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`} 
               onWheel={handleWheel} 
               onMouseDown={(e)=>handleStart(e.clientX, e.clientY)} 
               onMouseMove={(e)=>handleMove(e.clientX, e.clientY)} 
               onMouseUp={handleEnd} 
               onMouseLeave={handleEnd}
               onTouchStart={(e)=>{if(e.touches.length===1)handleStart(e.touches[0].clientX, e.touches[0].clientY)}}
               onTouchMove={(e)=>{if(e.touches.length===1)handleMove(e.touches[0].clientX, e.touches[0].clientY)}}
               onTouchEnd={handleEnd}
               >
             {geometry.map(g => ( 
               <g key={g.id}> 
                 <polygon points={g.verts.map(v=>`${v.x},${v.y}`).join(' ')} fill="white" stroke={g.stroke} strokeWidth={dynamicStroke} /> 
                 <text x={g.labelPos.x} y={g.labelPos.y} fontSize={dynamicFontSize} textAnchor="middle" fontWeight="bold">
                   <tspan fill="green">({g.idx}) </tspan>
                   <tspan fill={g.stroke}>{g.code}</tspan>
                 </text> 
               </g> 
             ))}
             {wallLines.map((w, i) => ( <line key={`wall-${i}`} x1={w.p1.x} y1={w.p1.y} x2={w.p2.x} y2={w.p2.y} stroke="blue" strokeWidth={dynamicStroke * 2.5} /> ))}
             {dimLines.map((d, i) => { const offVec = Vec.scale(d.normal, d.offset); const p1 = Vec.add(d.p1, offVec), p2 = Vec.add(d.p2, offVec); const mid = Vec.mid(p1, p2); const delta = Vec.sub(p2, p1); let ang = Math.atan2(delta.y, delta.x) * 180 / Math.PI; if(ang > 90 || ang < -90) ang += 180; const tick = Vec.scale(d.normal, 1.5); const txtPos = Vec.add(mid, Vec.scale(d.normal, 2.5)); return ( <g key={i}> <line x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke={d.color} strokeWidth={d.isGap?dynamicStroke*0.8:dynamicStroke*1.2} strokeDasharray={d.isGap?"1,1":""} /> <line x1={p1.x-tick.x} y1={p1.y-tick.y} x2={p1.x+tick.x} y2={p1.y+tick.y} stroke={d.color} strokeWidth={dynamicStroke*1.2} /> <line x1={p2.x-tick.x} y1={p2.y-tick.y} x2={p2.x+tick.x} y2={p2.y+tick.y} stroke={d.color} strokeWidth={dynamicStroke*1.2} /> <line x1={d.p1.x} y1={d.p1.y} x2={p1.x} y2={p1.y} stroke={d.color} strokeWidth={dynamicStroke*0.4} opacity="0.3" strokeDasharray="1,2" /> <line x1={d.p2.x} y1={d.p2.y} x2={p2.x} y2={p2.y} stroke={d.color} strokeWidth={dynamicStroke*0.4} opacity="0.3" strokeDasharray="1,2" /> 
             <text x={txtPos.x} y={txtPos.y} fill={d.color} fontSize={dynamicFontSize * 1.2} textAnchor="middle" transform={`rotate(${ang}, ${txtPos.x}, ${txtPos.y})`}> 
               {d.text} {d.label && <tspan fill="green" fontWeight="bold" fontSize={dynamicFontSize * 1.5}> {d.label}</tspan>} 
             </text> </g> ); })}
          </svg>
          <div className="status-overlay">Scroll to Zoom • Drag to Pan</div>
        </div>
      </div>
      </>
    );
  };

  const App = () => {
    const defaultCode = "A|B24|-120.00|0.00|34.50|-96.00|0.00|34.50; A|SB36|-96.00|0.00|34.50|-60.00|0.00|34.50; A|ERB36|-36.00|0.00|34.50|0.00|-36.00|34.50; B|B18|0.00|-66.00|34.50|-0.00|-84.00|34.50; A|W1830|-120.00|0.00|94.96|-102.00|0.00|94.96; A|W3030|-54.00|0.00|94.96|-24.00|0.00|94.96; A|DCW2430|-24.00|0.00|94.96|0.00|-24.00|94.96; B|W1230|0.00|-24.00|94.96|-0.00|-36.00|94.96; B|W3012|0.00|-36.00|94.96|-0.00|-66.00|94.96; B|W1830|-0.00|-66.00|94.96|-0.00|-84.00|94.96; B|W3612|0.00|-84.00|94.96|-0.00|-120.00|94.96";
    const [kitchenCode, setKitchenCode] = React.useState(defaultCode);
    return <KitchenVisualizer code={kitchenCode} setCode={setKitchenCode} />;
  };

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
</script>

</body>
</html>
