<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Cabinetry Visualizer Tool</title>

<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<style>
  /* --- 1. RESET & BASIC SETUP --- */
  * { box-sizing: border-box; }
  body { margin: 0; padding: 0; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #ffffff; overflow: hidden; }

  /* --- 2. LAYOUT CONTAINER --- */
  #root {
      width: 100vw;              
      height: 100vh;             
      display: flex;
  }

  /* --- 3. VISUALIZER STYLES --- */
  #kitchen-app-container { 
      display: flex; 
      flex-direction: column; 
      width: 100%; 
      height: 100%; 
      background-color: #ffffff; 
  }

  .controls { 
      flex: 0 0 auto; 
      padding: 12px 16px; 
      background: #ffffff; 
      border-bottom: 1px solid #e5e7eb; 
      display: flex; 
      gap: 12px; 
      align-items: center; 
      z-index: 10; 
  }
  
  .controls input { 
      flex: 1; 
      padding: 8px 12px; 
      border: 1px solid #d1d5db; 
      border-radius: 4px; 
      font-family: 'Consolas', 'Monaco', monospace; 
      font-size: 13px; 
      color: #374151; 
      outline: none; 
  }
  
  .controls button { 
      padding: 8px 16px; 
      background-color: #2563eb; 
      color: white; 
      border: none; 
      border-radius: 4px; 
      font-weight: 500; 
      font-size: 13px; 
      cursor: pointer; 
  }
  
  .controls button.secondary { background-color: #6b7280; }

  .viewport { 
      flex: 1 1 auto; 
      position: relative; 
      background-color: #ffffff; 
      cursor: grab; 
      overflow: hidden; 
      background-image: radial-gradient(circle, #e5e7eb 1px, transparent 1px); 
      background-size: 20px 20px; 
  }
  
  .viewport:active { cursor: grabbing; }
  
  svg { width: 100%; height: 100%; display: block; }
  
  .status-overlay { 
      position: absolute; 
      bottom: 12px; 
      left: 12px; 
      background: rgba(255, 255, 255, 0.9); 
      border: 1px solid #e5e7eb; 
      padding: 4px 8px; 
      border-radius: 4px; 
      font-size: 11px; 
      color: #6b7280; 
      pointer-events: none; 
  }
</style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
  // --- 1. MATH HELPERS ---
  const Vec = {
    add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
    sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
    scale: (a, s) => ({ x: a.x * s, y: a.y * s }),
    dot: (a, b) => a.x * b.x + a.y * b.y,
    dist: (a, b) => Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2),
    len: (a) => Math.sqrt(a.x**2 + a.y**2),
    norm: (a) => { const l = Math.sqrt(a.x**2 + a.y**2); return l < 1e-9 ? {x:0,y:0} : {x:a.x/l, y:a.y/l}; },
    mid: (a, b) => ({ x: (a.x + b.x)/2, y: (a.y + b.y)/2 }),
  };

  const formatDim = (v) => {
    if (v < 0.1) return '0"';
    const sixteenths = Math.round(v * 16);
    const inch = Math.floor(sixteenths / 16);
    const rem = Math.round(sixteenths % 16);
    if (rem === 0) return `${inch}"`;
    let n = rem, d = 16;
    while (n % 2 === 0) { n/=2; d/=2; }
    return inch === 0 ? `${n}/${d}"` : `${inch} ${n}/${d}"`;
  };

  // --- 2. KITCHEN VISUALIZER COMPONENT ---
  const KitchenVisualizer = ({ code, setCode }) => {
    const { useState, useRef, useMemo, useEffect } = React;
    const [viewBox, setViewBox] = useState({ x: -150, y: -150, width: 300, height: 300 });
    const isDragging = useRef(false);
    const lastPos = useRef({ x: 0, y: 0 });
    const svgRef = useRef(null);
    const dynamicFontSize = viewBox.width / 95; 
    const dynamicStroke = viewBox.width / 700; 

    // --- GEOMETRY PROCESSING ---
    const { geometry, dimLines, wallLines } = useMemo(() => {
      const items = code.replace(/;/g, '\n').split('\n').map(l => {
        const p = l.trim().split('|');
        if (p.length < 8) return null;
        return { 
          wall: p[0], code: p[1], 
          x1: parseFloat(p[2]), y1: -parseFloat(p[3]), 
          x2: parseFloat(p[5]), y2: -parseFloat(p[6]) 
        };
      }).filter(Boolean);

      const geo = [];
      const allSegments = [];

      items.forEach((item, idx) => {
        const c = item.code.toUpperCase();
        let depth = 24, stroke = 'black', type = 'std', isUpper = false;
        if (c.startsWith('W') || c.includes('WALL FILLER')) { depth = 12; stroke = 'red'; isUpper = true; }
        else if (c.startsWith('DCW')) { depth = 12; stroke = 'red'; type = 'diag'; isUpper = true; }
        else if (c.startsWith('ERB')) { depth = 24; stroke = 'black'; type = 'L'; }

        const P1 = {x: item.x1, y: item.y1}, P2 = {x: item.x2, y: item.y2};
        const vec = Vec.sub(P2, P1);
        if (Vec.len(vec) < 0.1) return;
        const u = Vec.norm(vec);
        const roomVec = { x: -u.y, y: u.x }; 
        let verts = [], labelPos = {x:0, y:0};
        
        const resolveBackDir = (uSeg, bisector) => {
            const n1 = { x: -uSeg.y, y: uSeg.x };
            const n2 = { x: uSeg.y, y: -uSeg.x };
            return Vec.dot(n1, bisector) < 0 ? n1 : n2;
        };
        const addSeg = (s, e, normal) => { allSegments.push({ start: s, end: e, normal, isUpper, wallRef: item.wall }); };

        if (type === 'std') {
           const F1 = Vec.add(P1, Vec.scale(roomVec, depth));
           const F2 = Vec.add(P2, Vec.scale(roomVec, depth));
           verts = [P1, P2, F2, F1];
           const labelShift = isUpper ? 0.5 : 0.9;
           labelPos = Vec.add(Vec.mid(P1, P2), Vec.scale(roomVec, depth * labelShift));
           addSeg(P1, P2, Vec.scale(roomVec, -1));
        } else if (type === 'L' || type === 'diag') {
           const C1 = {x:P1.x, y:P2.y}, C2 = {x:P2.x, y:P1.y};
           const cross = (P2.x-P1.x)*(C1.y-P2.y) - (P2.y-P1.y)*(C1.x-P2.x);
           const C = cross < 0 ? C1 : C2;
           const u1 = Vec.norm(Vec.sub(P1, C)), u2 = Vec.norm(Vec.sub(P2, C)); 
           const bisector = Vec.norm(Vec.add(u1, u2));
           const F1 = Vec.add(P1, Vec.scale(u2, depth)), F2 = Vec.add(P2, Vec.scale(u1, depth));
           if(type === 'L') { const Inner = Vec.add(C, Vec.add(Vec.scale(u1, depth), Vec.scale(u2, depth))); verts = [P1, C, P2, F2, Inner, F1]; } 
           else { verts = [P1, C, P2, F2, F1]; }
           const labelShift = isUpper ? 0.8 : 1.4;
           labelPos = Vec.add(C, Vec.scale(bisector, depth * labelShift));
           const dir1 = Vec.scale(u1, -1); const wallNormal1 = resolveBackDir(dir1, bisector); addSeg(C, P1, wallNormal1);
           const dir2 = Vec.scale(u2, -1); const wallNormal2 = resolveBackDir(dir2, bisector); addSeg(C, P2, wallNormal2);
        }
        geo.push({ id: idx, verts, labelPos, code: item.code, stroke, idx: idx+1 });
      });

      // --- GROUP SEGMENTS FOR DIMENSIONS AND WALL LINES ---
      const wallGroups = [];
      allSegments.forEach(seg => {
          const segVec = Vec.sub(seg.end, seg.start);
          if (Vec.len(segVec) < 0.1) return;
          const normal = Vec.norm(seg.normal);
          const dist = Vec.dot(seg.start, normal);
          let match = wallGroups.find(w => Vec.dot(w.normal, normal) > 0.99 && Math.abs(w.dist - dist) < 1.0);
          if (match) match.segments.push(seg);
          else wallGroups.push({ normal, dist, segments: [seg], ref: seg.wallRef });
      });

      const dims = [];
      const walls = [];

      wallGroups.forEach(wall => {
          const axis = { x: -wall.normal.y, y: wall.normal.x };
          const proj = p => Vec.dot(p, axis);
          let minT = Infinity, maxT = -Infinity, pStart = null, pEnd = null;
          
          wall.segments.forEach(s => {
             [s.start, s.end].forEach(p => {
                 const t = proj(p);
                 if(t < minT) { minT = t; pStart = p; }
                 if(t > maxT) { maxT = t; pEnd = p; }
             });
          });

          // DEFINE THE WALL LINE
          if(pStart && pEnd && Vec.dist(pStart, pEnd) > 1.0) {
              walls.push({ p1: pStart, p2: pEnd });
              dims.push({ p1: pStart, p2: pEnd, offset: 22, color: 'blue', text: formatDim(Vec.dist(pStart, pEnd)), normal: wall.normal, label: wall.ref });
          }

          const makeChain = (isUp, color, offset) => {
             const chainSegs = wall.segments.filter(s => s.isUpper === isUp);
             if (!chainSegs.length) return;
             const items = chainSegs.map(s => { const t1 = proj(s.start), t2 = proj(s.end); return { min: Math.min(t1,t2), max: Math.max(t1,t2), p_min: t1<t2?s.start:s.end, p_max: t1<t2?s.end:s.start }; });
             items.sort((a,b) => a.min - b.min);
             if (pStart) { const startGap = Vec.dist(pStart, items[0].p_min); if (startGap > 0.5) dims.push({ p1: pStart, p2: items[0].p_min, offset, color, text: formatDim(startGap), normal: wall.normal, isGap: true }); }
             for(let i=0; i<items.length; i++) {
                 const curr = items[i];
                 dims.push({ p1: curr.p_min, p2: curr.p_max, offset, color, text: formatDim(Vec.dist(curr.p_min, curr.p_max)), normal: wall.normal });
                 if(i < items.length-1) { const next = items[i+1]; const gap = Vec.dist(curr.p_max, next.p_min); if(gap > 0.5) dims.push({ p1: curr.p_max, p2: next.p_min, offset, color, text: formatDim(gap), normal: wall.normal, isGap: true }); }
             }
             if (pEnd) { const endGap = Vec.dist(items[items.length-1].p_max, pEnd); if (endGap > 0.5) dims.push({ p1: items[items.length-1].p_max, p2: pEnd, offset, color, text: formatDim(endGap), normal: wall.normal, isGap: true }); }
          };
          makeChain(true, 'red', 10);
          makeChain(false, 'black', 16);
      });

      return { geometry: geo, dimLines: dims, wallLines: walls };
    }, [code]);

    // --- ZOOM TO FIT ---
    useEffect(() => {
        if (!geometry.length) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        geometry.forEach(g => { g.verts.forEach(v => { if (v.x < minX) minX = v.x; if (v.x > maxX) maxX = v.x; if (v.y < minY) minY = v.y; if (v.y > maxY) maxY = v.y; }); });
        const w = maxX - minX; const h = maxY - minY;
        if (w === 0 || h === 0) return;
        const padding = Math.max(w, h) * 0.25; 
        setViewBox({ x: minX - padding, y: minY - padding, width: w + (padding * 2), height: h + (padding * 2) });
    }, [geometry]);

    const handleWheel = (e) => { e.preventDefault(); const s = e.deltaY > 0 ? 1.1 : 0.9; setViewBox(v => ({ x: v.x-(v.width*(s-1))/2, y: v.y-(v.height*(s-1))/2, width: v.width*s, height: v.height*s })); };
    const handleMove = (e) => { if(!isDragging.current) return; const r = svgRef.current.getBoundingClientRect(); const scaleX = viewBox.width / r.width; const scaleY = viewBox.height / r.height; const dx = (e.clientX - lastPos.current.x) * scaleX; const dy = (e.clientY - lastPos.current.y) * scaleY; setViewBox(v => ({...v, x: v.x - dx, y: v.y - dy})); lastPos.current = {x:e.clientX, y:e.clientY}; };

    return (
      <div id="kitchen-app-container">
        <div className="controls">
          <input value={code} onChange={e => setCode(e.target.value)} />
          <button onClick={() => setCode('')} className="secondary">Clear</button>
        </div>
        <div className="viewport">
          <svg ref={svgRef} viewBox={`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`} onWheel={handleWheel} onMouseDown={e=>{isDragging.current=true;lastPos.current={x:e.clientX,y:e.clientY}}} onMouseMove={handleMove} onMouseUp={()=>isDragging.current=false} onMouseLeave={()=>isDragging.current=false}>
             
             {/* 1. DRAW CABINETS (First layer, filled white) */}
             {geometry.map(g => ( <g key={g.id}> <polygon points={g.verts.map(v=>`${v.x},${v.y}`).join(' ')} fill="white" stroke={g.stroke} strokeWidth={dynamicStroke} /> <text x={g.labelPos.x} y={g.labelPos.y} fontSize={dynamicFontSize} textAnchor="middle" fill={g.stroke} fontWeight="bold">({g.idx}) {g.code}</text> </g> ))}

             {/* 2. DRAW WALLS (Blue Lines ON TOP of cabinets) */}
             {wallLines.map((w, i) => (
                 <line key={`wall-${i}`} x1={w.p1.x} y1={w.p1.y} x2={w.p2.x} y2={w.p2.y} stroke="blue" strokeWidth={dynamicStroke * 2.5} />
             ))}
             
             {/* 3. DRAW DIMENSIONS */}
             {dimLines.map((d, i) => { const offVec = Vec.scale(d.normal, d.offset); const p1 = Vec.add(d.p1, offVec), p2 = Vec.add(d.p2, offVec); const mid = Vec.mid(p1, p2); const delta = Vec.sub(p2, p1); let ang = Math.atan2(delta.y, delta.x) * 180 / Math.PI; if(ang > 90 || ang < -90) ang += 180; const tick = Vec.scale(d.normal, 1.5); const txtPos = Vec.add(mid, Vec.scale(d.normal, 2.5)); return ( <g key={i}> <line x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke={d.color} strokeWidth={d.isGap?dynamicStroke*0.8:dynamicStroke*1.2} strokeDasharray={d.isGap?"1,1":""} /> <line x1={p1.x-tick.x} y1={p1.y-tick.y} x2={p1.x+tick.x} y2={p1.y+tick.y} stroke={d.color} strokeWidth={dynamicStroke*1.2} /> <line x1={p2.x-tick.x} y1={p2.y-tick.y} x2={p2.x+tick.x} y2={p2.y+tick.y} stroke={d.color} strokeWidth={dynamicStroke*1.2} /> <line x1={d.p1.x} y1={d.p1.y} x2={p1.x} y2={p1.y} stroke={d.color} strokeWidth={dynamicStroke*0.4} opacity="0.3" strokeDasharray="1,2" /> <line x1={d.p2.x} y1={d.p2.y} x2={p2.x} y2={p2.y} stroke={d.color} strokeWidth={dynamicStroke*0.4} opacity="0.3" strokeDasharray="1,2" /> <text x={txtPos.x} y={txtPos.y} fill={d.color} fontSize={dynamicFontSize} textAnchor="middle" transform={`rotate(${ang}, ${txtPos.x}, ${txtPos.y})`}> {d.text} {d.label && <tspan fill="green" fontWeight="bold">{d.label}</tspan>} </text> </g> ); })}
          </svg>
          <div className="status-overlay">Scroll to Zoom â€¢ Drag to Pan</div>
        </div>
      </div>
    );
  };

  // --- 3. MAIN APP COMPONENT ---
  const App = () => {
    // Default sample data so the tool isn't blank on load
    const defaultCode = "A|B24|-120.00|0.00|34.50|-96.00|0.00|34.50; A|SB36|-96.00|0.00|34.50|-60.00|0.00|34.50; A|ERB36|-36.00|0.00|34.50|0.00|-36.00|34.50; B|B18|0.00|-66.00|34.50|-0.00|-84.00|34.50; A|W1830|-120.00|0.00|94.96|-102.00|0.00|94.96; A|W3030|-54.00|0.00|94.96|-24.00|0.00|94.96; A|DCW2430|-24.00|0.00|94.96|0.00|-24.00|94.96; B|W1230|0.00|-24.00|94.96|-0.00|-36.00|94.96; B|W3012|0.00|-36.00|94.96|-0.00|-66.00|94.96; B|W1830|-0.00|-66.00|94.96|-0.00|-84.00|94.96; B|W3612|0.00|-84.00|94.96|-0.00|-120.00|94.96";
    
    const [kitchenCode, setKitchenCode] = React.useState(defaultCode);

    return <KitchenVisualizer code={kitchenCode} setCode={setKitchenCode} />;
  };

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
</script>

</body>
</html>
