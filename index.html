<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Cabinetry Visualizer Tool</title>

<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<style>
  /* --- 1. RESET & BASIC SETUP --- */
  * { box-sizing: border-box; }
  body { margin: 0; padding: 0; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #ffffff; overflow: hidden; overscroll-behavior: none; }

  /* --- 2. LAYOUT CONTAINER --- */
  #root {
      width: 100vw;              
      height: 100vh;             
      display: flex;
  }

  /* --- 3. SIDEBAR STYLES --- */
  .sidebar {
      background: #f8f9fa;
      border-right: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      transition: width 0.3s ease, min-width 0.3s ease;
      overflow: hidden;
      z-index: 20;
  }
  
  .sidebar.open { width: 350px; min-width: 350px; }
  .sidebar.closed { width: 0; min-width: 0; border-right: none; }

  .sidebar-mobile-nav {
      background: #1a252f; 
      padding: 10px 15px;
      display: none;
      flex-shrink: 0;
      flex-direction: column;
      gap: 10px;
      border-bottom: 1px solid #34495e;
  }
  
  .sidebar-back-btn {
      width: 100%;
      background: #34495e;
      border: 1px solid #46627f;
      color: white;
      padding: 12px;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 10px;
  }

  .sidebar-input-group {
      display: flex;
      gap: 8px;
  }
  .sidebar-input-group input, .sidebar-input-group textarea {
      flex: 1;
      padding: 10px;
      border-radius: 4px;
      border: none;
      background: #fff;
      font-size: 16px;
      outline: none;
      color: #333;
      font-family: inherit;
      resize: vertical;
  }

  .sidebar-header {
      padding: 20px 15px;
      background: #2c3e50;
      color: white;
      font-size: 18px;
      font-weight: bold;
      flex-shrink: 0;
  }

  .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      -webkit-overflow-scrolling: touch; 
  }

  .wall-group { margin-bottom: 25px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
  .wall-title { font-size: 20px; font-weight: 700; color: #333; margin-bottom: 12px; display: flex; align-items: center; gap: 10px; }
  .wall-badge { background: #2563eb; color: white; padding: 4px 10px; border-radius: 6px; font-size: 16px; }
  .cat-title { font-size: 14px; text-transform: uppercase; color: #888; font-weight: 700; margin: 12px 0 6px 0; letter-spacing: 0.5px; }
  
  .cab-item { 
      font-size: 16px; 
      padding: 12px 14px; 
      background: white; 
      border: 1px solid #ddd; 
      margin-bottom: 8px; 
      border-radius: 8px; 
      display: flex; 
      justify-content: space-between; 
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
  }
  .cab-idx { font-weight: bold; color: green; margin-right: 12px; }

  /* --- 4. VISUALIZER CONTAINER --- */
  #kitchen-app-container { 
      flex: 1;
      display: flex; 
      flex-direction: column; 
      height: 100%; 
      background-color: #ffffff; 
      min-width: 0;
  }

  .control-panel {
      flex: 0 0 auto;
      background: #ffffff;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      flex-direction: column;
      z-index: 10;
  }

  .input-row {
      padding: 12px 16px;
      display: flex;
      gap: 12px;
      align-items: center;
  }
  .input-row.primary { background: #f0f7ff; border-bottom: 1px solid #eef2f6; padding: 15px 16px; }
  .input-label { font-size: 14px; font-weight: 600; color: #555; white-space: nowrap; }

  .control-panel input, .control-panel textarea { 
      flex: 1; 
      padding: 12px; 
      border: 1px solid #d1d5db; 
      border-radius: 6px; 
      font-family: 'Consolas', 'Monaco', monospace; 
      font-size: 16px; 
      color: #374151; 
      outline: none; 
      resize: vertical;
  }
  
  .control-panel button { 
      padding: 10px 20px; 
      background-color: #2563eb; 
      color: white; 
      border: none; 
      border-radius: 6px; 
      font-weight: 600; 
      font-size: 14px; 
      cursor: pointer; 
      white-space: nowrap;
      height: 44px; 
  }
  
  .control-panel button.secondary { background-color: #6b7280; }
  
  .control-panel button.toggle-sidebar { 
      background-color: #2c3e50; 
      display: flex; 
      align-items: center; 
      gap: 8px; 
      font-size: 16px;
      padding: 10px 24px;
  }

  /* --- VIEWPORT --- */
  .viewport { 
      flex: 1 1 auto; 
      position: relative; 
      background-color: #ffffff; 
      cursor: grab; 
      overflow: hidden; 
      background-image: radial-gradient(circle, #e5e7eb 1px, transparent 1px); 
      background-size: 20px 20px;
      touch-action: none; 
  }
  .viewport:active { cursor: grabbing; }
  
  svg { width: 100%; height: 100%; display: block; touch-action: none; }
  
  .status-overlay { 
      position: absolute; 
      bottom: 12px; 
      left: 12px; 
      background: rgba(255, 255, 255, 0.9); 
      border: 1px solid #e5e7eb; 
      padding: 6px 10px; 
      border-radius: 4px; 
      font-size: 12px; 
      color: #6b7280; 
      pointer-events: none; 
  }
  
  /* Mobile adjustments */
  @media (max-width: 600px) {
      .input-label { display: none; } 
      .sidebar.open { width: 100%; min-width: 100%; position: absolute; height: 100%; z-index: 999; }
      .sidebar-mobile-nav { display: flex !important; } 
      .control-panel button.toggle-sidebar { width: 100%; justify-content: center; }
  }
</style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
  // --- 1. MATH HELPERS ---
  const Vec = {
    add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
    sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
    scale: (a, s) => ({ x: a.x * s, y: a.y * s }),
    dot: (a, b) => a.x * b.x + a.y * b.y,
    dist: (a, b) => Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2),
    len: (a) => Math.sqrt(a.x**2 + a.y**2),
    norm: (a) => { const l = Math.sqrt(a.x**2 + a.y**2); return l < 1e-9 ? {x:0,y:0} : {x:a.x/l, y:a.y/l}; },
    mid: (a, b) => ({ x: (a.x + b.x)/2, y: (a.y + b.y)/2 }),
  };

  const formatDim = (v) => {
    if (v < 0.1) return '0"';
    const sixteenths = Math.round(v * 16);
    const inch = Math.floor(sixteenths / 16);
    const rem = Math.round(sixteenths % 16);
    if (rem === 0) return `${inch}"`;
    let n = rem, d = 16;
    while (n % 2 === 0) { n/=2; d/=2; }
    return inch === 0 ? `${n}/${d}"` : `${inch} ${n}/${d}"`;
  };

  // --- 2. KITCHEN VISUALIZER COMPONENT ---
  const KitchenVisualizer = ({ code, setCode }) => {
    const { useState, useRef, useMemo, useEffect } = React;
    const [viewBox, setViewBox] = useState({ x: -150, y: -150, width: 300, height: 300 });
    const [sidebarOpen, setSidebarOpen] = useState(false); 
    const [description, setDescription] = useState("");
    const [isGenerating, setIsGenerating] = useState(false); 
    
    useEffect(() => {
        if (window.innerWidth > 600) setSidebarOpen(true);
    }, []);

    // --- LIVE UPDATE LOGIC ---
    useEffect(() => {
        if (!description.trim()) return;

        const timer = setTimeout(async () => {
            setIsGenerating(true);
            try {
                const response = await fetch('https://api-draw.cabinetryexpress.com/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: description })
                });
                
                const data = await response.json();
                if (data.code) {
                    setCode(data.code);
                }
            } catch (err) {
                console.error("Server Connection Error:", err);
            } finally {
                setIsGenerating(false);
            }
        }, 50);

        return () => clearTimeout(timer);
    }, [description, setCode]);

    const isDragging = useRef(false);
    const lastPos = useRef({ x: 0, y: 0 });
    const svgRef = useRef(null);
    const dynamicFontSize = viewBox.width / 50; 
    const dynamicStroke = viewBox.width / 700; 

    // --- PARSE DATA FOR LIST VIEW (UI Logic) ---
    const organizedData = useMemo(() => {
        const walls = {};
        if (!code) return walls;
        
        // Use || and ; as valid split delimiters
        const items = code.replace(/\|\|/g, '\n').replace(/;/g, '\n').split('\n').map((l, i) => {
            const p = l.trim().split('|');
            if (p.length < 8) return null; // Exclude explicit wall lines from the list
            const c = p[1].toUpperCase();
            const isUpper = (c.startsWith('W') || c.includes('WALL FILLER') || c.startsWith('DCW'));
            return { wall: p[0], code: p[1], idx: i + 1, type: isUpper ? 'upper' : 'base' };
        }).filter(Boolean);
        
        items.forEach(item => {
            if (!walls[item.wall]) walls[item.wall] = { base: [], upper: [] };
            if (item.type === 'base') walls[item.wall].base.push(item);
            else walls[item.wall].upper.push(item);
        });
        
        return Object.keys(walls).sort().reduce((obj, key) => { obj[key] = walls[key]; return obj; }, {});
    }, [code]);

    // --- GEOMETRY PROCESSING ---
    const { geometry, dimLines, wallLines } = useMemo(() => {
      const items = [];
      const walls_data = [];

      // Parse code for explicit walls AND cabinets using || or ; delimiters
      (code || "").replace(/\|\|/g, '\n').replace(/;/g, '\n').split('\n').forEach(l => {
        const p = l.trim().split('|');
        if (p.length >= 8) {
          items.push({ 
            wall: p[0], code: p[1], 
            x1: parseFloat(p[2]), y1: -parseFloat(p[3]), 
            x2: parseFloat(p[5]), y2: -parseFloat(p[6]) 
          });
        } else if (p.length >= 5 && !isNaN(parseFloat(p[1]))) {
          walls_data.push({
            wallRef: p[0],
            x1: parseFloat(p[1]), y1: -parseFloat(p[2]),
            x2: parseFloat(p[3]), y2: -parseFloat(p[4])
          });
        }
      });
      
      const geo = []; 
      const allSegments = [];

      // Process Cabinet Shapes
      items.forEach((item, idx) => {
        const c = item.code.toUpperCase();
        let depth = 24, stroke = 'black', type = 'std', isUpper = false;
        if (c.startsWith('W') || c.includes('WALL FILLER')) { depth = 12; stroke = 'red'; isUpper = true; }
        else if (c.startsWith('DCW')) { depth = 12; stroke = 'red'; type = 'diag'; isUpper = true; }
        else if (c.startsWith('ERB') || c.startsWith('LSB') || c.startsWith('BBC')) { depth = 24; stroke = 'black'; type = 'L'; }
        
        const P1 = {x: item.x1, y: item.y1}, P2 = {x: item.x2, y: item.y2};
        const vec = Vec.sub(P2, P1);
        if (Vec.len(vec) < 0.1) return;
        const u = Vec.norm(vec); const roomVec = { x: -u.y, y: u.x }; 
        let verts = [], labelPos = {x:0, y:0};
        
        const resolveBackDir = (uSeg, bisector) => { const n1 = { x: -uSeg.y, y: uSeg.x }; const n2 = { x: uSeg.y, y: -uSeg.x }; return Vec.dot(n1, bisector) < 0 ? n1 : n2; };
        const addSeg = (s, e, normal) => { allSegments.push({ start: s, end: e, normal, isUpper, wallRef: item.wall }); };
        
        if (type === 'std') {
           const F1 = Vec.add(P1, Vec.scale(roomVec, depth)); const F2 = Vec.add(P2, Vec.scale(roomVec, depth));
           verts = [P1, P2, F2, F1]; const labelShift = isUpper ? 0.5 : 0.9;
           labelPos = Vec.add(Vec.mid(P1, P2), Vec.scale(roomVec, depth * labelShift)); addSeg(P1, P2, Vec.scale(roomVec, -1));
        } else if (type === 'L' || type === 'diag') {
           const C1 = {x:P1.x, y:P2.y}, C2 = {x:P2.x, y:P1.y}; const cross = (P2.x-P1.x)*(C1.y-P2.y) - (P2.y-P1.y)*(C1.x-P2.x); const C = cross < 0 ? C1 : C2;
           const u1 = Vec.norm(Vec.sub(P1, C)), u2 = Vec.norm(Vec.sub(P2, C)); const bisector = Vec.norm(Vec.add(u1, u2));
           const F1 = Vec.add(P1, Vec.scale(u2, depth)), F2 = Vec.add(P2, Vec.scale(u1, depth));
           if(type === 'L') { const Inner = Vec.add(C, Vec.add(Vec.scale(u1, depth), Vec.scale(u2, depth))); verts = [P1, C, P2, F2, Inner, F1]; } 
           else { verts = [P1, C, P2, F2, F1]; }
           const labelShift = isUpper ? 0.8 : 1.4; labelPos = Vec.add(C, Vec.scale(bisector, depth * labelShift));
           const dir1 = Vec.scale(u1, -1); const wallNormal1 = resolveBackDir(dir1, bisector); addSeg(C, P1, wallNormal1);
           const dir2 = Vec.scale(u2, -1); const wallNormal2 = resolveBackDir(dir2, bisector); addSeg(C, P2, wallNormal2);
        }
        geo.push({ id: idx, verts, labelPos, code: item.code, stroke, idx: idx+1 });
      });

      // Group Collinear Cabinet Segments (for attaching dimensions)
      const wallGroups = [];
      allSegments.forEach(seg => {
          const segVec = Vec.sub(seg.end, seg.start);
          if (Vec.len(segVec) < 0.1) return;
          const normal = Vec.norm(seg.normal);
          const dist = Vec.dot(seg.start, normal);
          let match = wallGroups.find(w => Math.abs(Vec.dot(w.normal, normal)) > 0.99 && Math.abs(w.dist - dist) < 1.0);
          if (match) match.segments.push(seg);
          else wallGroups.push({ normal, dist, segments: [seg], ref: seg.wallRef });
      });

      // FALLBACK: If explicit walls don't exist in the code string, synthesize them implicitly
      if (walls_data.length === 0) {
          wallGroups.forEach(wall => {
              const axis = { x: -wall.normal.y, y: wall.normal.x }; 
              const proj = p => Vec.dot(p, axis);
              let minT = Infinity, maxT = -Infinity, pStart = null, pEnd = null;

              wall.segments.forEach(s => { 
                 [s.start, s.end].forEach(p => { 
                     const t = proj(p); 
                     if(t < minT) { minT = t; pStart = p; } 
                     if(t > maxT) { maxT = t; pEnd = p; } 
                 }); 
              });

              if(pStart && pEnd && Vec.dist(pStart, pEnd) > 1.0) { 
                  walls_data.push({
                      wallRef: wall.ref,
                      x1: pStart.x, y1: pStart.y,
                      x2: pEnd.x, y2: pEnd.y
                  });
              }
          });
      }

      const dims = []; 
      const walls = [];

      // 1. Draw Explicit Walls and Overall Dimensions
      walls_data.forEach(w => {
          const p1 = { x: w.x1, y: w.y1 };
          const p2 = { x: w.x2, y: w.y2 };
          walls.push({ p1, p2 }); // For blue line rendering

          const wVec = Vec.sub(p2, p1);
          if (Vec.len(wVec) < 0.1) return;
          const wDir = Vec.norm(wVec);
          let normal = { x: -wDir.y, y: wDir.x }; 

          // Attempt to align the dimension normal precisely with the cabinets
          for (const group of wallGroups) {
              if (Math.abs(Vec.dot(wDir, group.normal)) > 0.1) continue; 
              const cabPt = group.segments[0].start;
              const vecToWall = Vec.sub(p1, cabPt);
              const distPerp = Math.abs(Vec.dot(vecToWall, group.normal));
              if (distPerp < 5.0) { // Tolerance increased for floating-point safety
                  normal = group.normal;
                  break;
              }
          }

          dims.push({
              p1, p2, offset: 22, color: 'blue',
              text: formatDim(Vec.dist(p1, p2)), normal, label: w.wallRef
          });
      });

      // 2. Make Detail Chains mapping to Walls
      wallGroups.forEach(wall => {
          let globalStart = null, globalEnd = null;
          const axis = { x: -wall.normal.y, y: wall.normal.x }; 
          const proj = p => Vec.dot(p, axis);

          // Find matching wall for starting/ending anchor points
          let matchedWall = walls_data.find(w => {
              const w1 = {x: w.x1, y: w.y1};
              const w2 = {x: w.x2, y: w.y2};
              const wVec = Vec.sub(w2, w1);
              if (Vec.len(wVec) < 0.1) return false;
              const wDir = Vec.norm(wVec);
              if (Math.abs(Vec.dot(wDir, wall.normal)) > 0.1) return false;
              
              const cabPt = wall.segments[0].start;
              const distPerp = Math.abs(Vec.dot(Vec.sub(w1, cabPt), wall.normal));
              return distPerp < 5.0; // Tolerance safely increased
          });

          if (matchedWall) {
              const pts = [
                  {x: matchedWall.x1, y: matchedWall.y1}, 
                  {x: matchedWall.x2, y: matchedWall.y2}
              ];
              const proj0 = proj(pts[0]), proj1 = proj(pts[1]);
              if (proj0 < proj1) { globalStart = pts[0]; globalEnd = pts[1]; }
              else { globalStart = pts[1]; globalEnd = pts[0]; }
          }

          const makeChain = (isUp, color, offset) => {
             const chainSegs = wall.segments.filter(s => s.isUpper === isUp); 
             if (!chainSegs.length) return;
             
             const items = chainSegs.map(s => { 
                 const t1 = proj(s.start), t2 = proj(s.end); 
                 return { min: Math.min(t1,t2), max: Math.max(t1,t2), p_min: t1<t2?s.start:s.end, p_max: t1<t2?s.end:s.start }; 
             });
             items.sort((a,b) => a.min - b.min);
             
             // Setup reliable start/end points with or without matched explicit walls
             let startPt = globalStart || items[0].p_min;
             let endPt = globalEnd || items[items.length-1].p_max;

             const startGap = Vec.dist(startPt, items[0].p_min); 
             if (startGap > 0.5) dims.push({ p1: startPt, p2: items[0].p_min, offset, color, text: formatDim(startGap), normal: wall.normal, isGap: true }); 
             
             for(let i=0; i<items.length; i++) {
                 const curr = items[i]; 
                 dims.push({ p1: curr.p_min, p2: curr.p_max, offset, color, text: formatDim(Vec.dist(curr.p_min, curr.p_max)), normal: wall.normal });
                 if(i < items.length-1) { 
                     const next = items[i+1]; 
                     const gap = Vec.dist(curr.p_max, next.p_min); 
                     if(gap > 0.5) dims.push({ p1: curr.p_max, p2: next.p_min, offset, color, text: formatDim(gap), normal: wall.normal, isGap: true }); 
                 }
             }
             
             const endGap = Vec.dist(items[items.length-1].p_max, endPt); 
             if (endGap > 0.5) dims.push({ p1: items[items.length-1].p_max, p2: endPt, offset, color, text: formatDim(endGap), normal: wall.normal, isGap: true }); 
          };
          
          makeChain(true, 'red', 10); 
          makeChain(false, 'black', 16);
      });

      return { geometry: geo, dimLines: dims, wallLines: walls };
    }, [code]);

    // --- INTERACTION ---
    useEffect(() => {
        if (!geometry.length && !wallLines.length) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        
        geometry.forEach(g => { g.verts.forEach(v => { if (v.x < minX) minX = v.x; if (v.x > maxX) maxX = v.x; if (v.y < minY) minY = v.y; if (v.y > maxY) maxY = v.y; }); });
        wallLines.forEach(w => { [w.p1, w.p2].forEach(v => { if (v.x < minX) minX = v.x; if (v.x > maxX) maxX = v.x; if (v.y < minY) minY = v.y; if (v.y > maxY) maxY = v.y; }); });
        
        const w = maxX - minX; const h = maxY - minY; if (w === 0 || h === 0) return;
        const padding = Math.max(w, h) * 0.25; setViewBox({ x: minX - padding, y: minY - padding, width: w + (padding * 2), height: h + (padding * 2) });
    }, [geometry, wallLines]);

    const handleWheel = (e) => { e.preventDefault(); const s = e.deltaY > 0 ? 1.1 : 0.9; setViewBox(v => ({ x: v.x-(v.width*(s-1))/2, y: v.y-(v.height*(s-1))/2, width: v.width*s, height: v.height*s })); };
    const handleStart = (x, y) => { isDragging.current = true; lastPos.current = { x, y }; };
    const handleEnd = () => { isDragging.current = false; };
    const handleMove = (x, y) => { if (!isDragging.current) return; const r = svgRef.current.getBoundingClientRect(); const scaleX = viewBox.width / r.width; const scaleY = viewBox.height / r.height; const dx = (x - lastPos.current.x) * scaleX; const dy = (y - lastPos.current.y) * scaleY; setViewBox(v => ({...v, x: v.x - dx, y: v.y - dy})); lastPos.current = { x, y }; };

    return (
      <>
      <div className={`sidebar ${sidebarOpen ? 'open' : 'closed'}`}>
         <div className="sidebar-mobile-nav">
            <button className="sidebar-back-btn" onClick={() => setSidebarOpen(false)}>◀ Back to Drawing</button>
            <div className="sidebar-input-group">
                <textarea 
                    value={description} 
                    onChange={e => setDescription(e.target.value)}
                    placeholder="Describe Kitchen..." 
                    rows="3"
                />
            </div>
         </div>
         
         <div className="sidebar-header">Cabinet List</div>
         
         <div className="sidebar-content">
            {Object.keys(organizedData).map(wallKey => (
                <div key={wallKey} className="wall-group">
                    <div className="wall-title">
                        <span className="wall-badge">Wall {wallKey}</span>
                    </div>
                    {organizedData[wallKey].base.length > 0 && (
                        <>
                            <div className="cat-title">Base Cabinets</div>
                            {organizedData[wallKey].base.map((item, i) => (
                                <div key={i} className="cab-item">
                                    <span><span className="cab-idx">({item.idx})</span> {item.code}</span>
                                </div>
                            ))}
                        </>
                    )}
                    {organizedData[wallKey].upper.length > 0 && (
                        <>
                            <div className="cat-title">Wall Cabinets</div>
                            {organizedData[wallKey].upper.map((item, i) => (
                                <div key={i} className="cab-item">
                                    <span><span className="cab-idx">({item.idx})</span> {item.code}</span>
                                </div>
                            ))}
                        </>
                    )}
                </div>
            ))}
         </div>
      </div>

      <div id="kitchen-app-container">
        <div className="control-panel">
          <div className="input-row primary">
             <button className="toggle-sidebar" onClick={() => setSidebarOpen(!sidebarOpen)} title="Toggle List View">
                {sidebarOpen ? '◀' : '☰ List View'}
             </button>
             <div className="input-label">Describe Kitchen: {isGenerating && "(Generating...)"}</div>
             <textarea 
                 value={description} 
                 onChange={e => setDescription(e.target.value)} 
                 placeholder="e.g. Wall A base 24, sink 36..." 
                 rows="3"
             />
          </div>
          
          {/* Hidden Kitchen Code View */}
          <div className="input-row" style={{ display: 'none' }}>
             <div className="input-label">Kitchen Code:</div>
             <input value={code} onChange={e => setCode(e.target.value)} />
             <button onClick={() => setCode('')} className="secondary">Clear</button>
          </div>
        </div>

        <div className="viewport">
          <svg ref={svgRef} viewBox={`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`} 
               onWheel={handleWheel} 
               onMouseDown={(e)=>handleStart(e.clientX, e.clientY)} 
               onMouseMove={(e)=>handleMove(e.clientX, e.clientY)} 
               onMouseUp={handleEnd} 
               onMouseLeave={handleEnd}
               onTouchStart={(e)=>{if(e.touches.length===1)handleStart(e.touches[0].clientX, e.touches[0].clientY)}}
               onTouchMove={(e)=>{if(e.touches.length===1)handleMove(e.touches[0].clientX, e.touches[0].clientY)}}
               onTouchEnd={handleEnd}
               >
             {geometry.map(g => ( 
               <g key={g.id}> 
                 <polygon points={g.verts.map(v=>`${v.x},${v.y}`).join(' ')} fill="white" stroke={g.stroke} strokeWidth={dynamicStroke} /> 
                 <text x={g.labelPos.x} y={g.labelPos.y} fontSize={dynamicFontSize} textAnchor="middle" fontWeight="bold">
                   <tspan fill="green">({g.idx}) </tspan>
                   <tspan fill={g.stroke}>{g.code}</tspan>
                 </text> 
               </g> 
             ))}

             {wallLines.map((w, i) => ( <line key={`wall-${i}`} x1={w.p1.x} y1={w.p1.y} x2={w.p2.x} y2={w.p2.y} stroke="blue" strokeWidth={dynamicStroke * 2.5} /> ))}

             {dimLines.map((d, i) => { const offVec = Vec.scale(d.normal, d.offset); const p1 = Vec.add(d.p1, offVec), p2 = Vec.add(d.p2, offVec); const mid = Vec.mid(p1, p2); const delta = Vec.sub(p2, p1); let ang = Math.atan2(delta.y, delta.x) * 180 / Math.PI; if(ang > 90 || ang < -90) ang += 180; const tick = Vec.scale(d.normal, 1.5); const txtPos = Vec.add(mid, Vec.scale(d.normal, 2.5)); return ( <g key={i}> <line x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke={d.color} strokeWidth={d.isGap?dynamicStroke*0.8:dynamicStroke*1.2} strokeDasharray={d.isGap?"1,1":""} /> <line x1={p1.x-tick.x} y1={p1.y-tick.y} x2={p1.x+tick.x} y2={p1.y+tick.y} stroke={d.color} strokeWidth={dynamicStroke*1.2} /> <line x1={p2.x-tick.x} y1={p2.y-tick.y} x2={p2.x+tick.x} y2={p2.y+tick.y} stroke={d.color} strokeWidth={dynamicStroke*1.2} /> <line x1={d.p1.x} y1={d.p1.y} x2={p1.x} y2={p1.y} stroke={d.color} strokeWidth={dynamicStroke*0.4} opacity="0.3" strokeDasharray="1,2" /> <line x1={d.p2.x} y1={d.p2.y} x2={p2.x} y2={p2.y} stroke={d.color} strokeWidth={dynamicStroke*0.4} opacity="0.3" strokeDasharray="1,2" /> 
             <text x={txtPos.x} y={txtPos.y} fill={d.color} fontSize={dynamicFontSize * 1.2} textAnchor="middle" transform={`rotate(${ang}, ${txtPos.x}, ${txtPos.y})`}> 
               {d.text} {d.label && <tspan fill="green" fontWeight="bold" fontSize={dynamicFontSize * 1.5}> {d.label}</tspan>} 
             </text> </g> ); })}
          </svg>
          <div className="status-overlay">Scroll to Zoom • Drag to Pan</div>
        </div>
      </div>
      </>
    );
  };

  const App = () => {
    const [kitchenCode, setKitchenCode] = React.useState("");
    return <KitchenVisualizer code={kitchenCode} setCode={setKitchenCode} />;
  };

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
</script>

</body>
</html>
