<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Cabinetry Visualizer Tool - Final</title>

<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<style>
  /* --- 1. RESET & BASIC SETUP --- */
  * { box-sizing: border-box; }
  body { margin: 0; padding: 0; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #ffffff; overflow: hidden; overscroll-behavior: none; }

  /* --- 2. LAYOUT CONTAINER --- */
  #root {
      width: 100vw;              
      height: 100vh;             
      display: flex;
  }

  /* --- 3. SIDEBAR STYLES --- */
  .sidebar {
      background: #f8f9fa; border-right: 1px solid #ddd; display: flex; flex-direction: column;
      transition: width 0.3s ease, min-width 0.3s ease; overflow: hidden; z-index: 20;
  }
  
  .sidebar.open { width: 350px; min-width: 350px; }
  .sidebar.closed { width: 0; min-width: 0; border-right: none; }

  .sidebar-mobile-nav {
      background: #1a252f; padding: 10px 15px; display: none; flex-shrink: 0;
      flex-direction: column; gap: 10px; border-bottom: 1px solid #34495e;
  }
  
  .sidebar-back-btn {
      width: 100%; background: #34495e; border: 1px solid #46627f; color: white;
      padding: 12px; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;
      text-align: left; display: flex; align-items: center; gap: 10px;
  }

  .sidebar-input-group { display: flex; gap: 8px; }
  .sidebar-input-group textarea {
      flex: 1; padding: 10px; border-radius: 4px; border: none; background: #fff;
      font-size: 16px; outline: none; color: #333; font-family: inherit; resize: vertical;
  }

  .sidebar-header { padding: 20px 15px; background: #2c3e50; color: white; font-size: 18px; font-weight: bold; flex-shrink: 0; }
  .sidebar-content { flex: 1; overflow-y: auto; padding: 15px; -webkit-overflow-scrolling: touch; }
  .wall-group { margin-bottom: 25px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
  .wall-title { font-size: 20px; font-weight: 700; color: #333; margin-bottom: 12px; display: flex; align-items: center; gap: 10px; }
  .wall-badge { background: #2563eb; color: white; padding: 4px 10px; border-radius: 6px; font-size: 16px; }
  .cat-title { font-size: 14px; text-transform: uppercase; color: #888; font-weight: 700; margin: 12px 0 6px 0; letter-spacing: 0.5px; }
  
  .cab-item { 
      font-size: 16px; padding: 12px 14px; background: white; border: 1px solid #ddd; 
      margin-bottom: 8px; border-radius: 8px; display: flex; justify-content: space-between; 
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
  }
  .cab-idx { font-weight: bold; color: green; margin-right: 12px; }

  /* --- 4. VISUALIZER CONTAINER --- */
  #kitchen-app-container { 
      flex: 1; display: flex; flex-direction: column; height: 100%; background-color: #ffffff; min-width: 0;
  }

  .control-panel {
      flex: 0 0 auto; background: #ffffff; border-bottom: 1px solid #e5e7eb; display: flex; flex-direction: column; z-index: 10;
  }

  .input-row { padding: 12px 16px; display: flex; gap: 12px; align-items: center; }
  .input-row.primary { background: #f0f7ff; border-bottom: 1px solid #eef2f6; padding: 15px 16px; }
  .input-label { font-size: 14px; font-weight: 600; color: #555; white-space: nowrap; }

  .control-panel input, .control-panel textarea { 
      flex: 1; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; font-family: 'Consolas', 'Monaco', monospace; 
      font-size: 16px; color: #374151; outline: none; resize: vertical;
  }
  
  .control-panel button { 
      padding: 10px 20px; background-color: #2563eb; color: white; border: none; border-radius: 6px; 
      font-weight: 600; font-size: 14px; cursor: pointer; white-space: nowrap; height: 44px; 
  }
  .control-panel button.secondary { background-color: #6b7280; }
  
  /* Left Controls Button Styling */
  .left-controls { display: flex; flex-direction: column; gap: 8px; flex-shrink: 0; }
  .control-panel button.toggle-view, .control-panel button.toggle-sidebar { 
      background-color: #2c3e50; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      gap: 8px; 
      font-size: 14px; 
      padding: 10px 24px; 
      width: 100%; 
  }

  /* --- VIEWPORT --- */
  .viewport { 
      flex: 1 1 auto; position: relative; background-color: #ffffff; overflow: hidden; touch-action: none; 
  }
  .viewport.mode-2d {
      background-image: radial-gradient(circle, #e5e7eb 1px, transparent 1px); background-size: 20px 20px; cursor: grab;
  }
  .viewport.mode-2d:active { cursor: grabbing; }
  
  svg { width: 100%; height: 100%; display: block; touch-action: none; }
  
  .status-overlay { 
      position: absolute; bottom: 12px; left: 12px; background: rgba(255, 255, 255, 0.9); border: 1px solid #e5e7eb; 
      padding: 6px 10px; border-radius: 4px; font-size: 12px; color: #6b7280; pointer-events: none; z-index: 50;
  }
  
  /* Mobile adjustments */
  @media (max-width: 600px) {
      .input-label { display: none; } 
      .sidebar.open { width: 100%; min-width: 100%; position: absolute; height: 100%; z-index: 999; }
      .sidebar-mobile-nav { display: flex !important; } 
      .left-controls { width: 100%; }
      .input-row.primary { flex-direction: column; align-items: stretch; }
  }
</style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
  // --- 1. MATH HELPERS ---
  const Vec = {
    add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
    sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
    scale: (a, s) => ({ x: a.x * s, y: a.y * s }),
    dot: (a, b) => a.x * b.x + a.y * b.y,
    dist: (a, b) => Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2),
    len: (a) => Math.sqrt(a.x**2 + a.y**2),
    norm: (a) => { const l = Math.sqrt(a.x**2 + a.y**2); return l < 1e-9 ? {x:0,y:0} : {x:a.x/l, y:a.y/l}; },
    mid: (a, b) => ({ x: (a.x + b.x)/2, y: (a.y + b.y)/2 }),
  };

  const formatDim = (v) => {
    if (v < 0.1) return '0"';
    const sixteenths = Math.round(v * 16);
    const inch = Math.floor(sixteenths / 16);
    const rem = Math.round(sixteenths % 16);
    if (rem === 0) return `${inch}"`;
    let n = rem, d = 16;
    while (n % 2 === 0) { n/=2; d/=2; }
    return inch === 0 ? `${n}/${d}"` : `${inch} ${n}/${d}"`;
  };

  // --- 2. THREE.JS 3D COMPONENT ---
  const Kitchen3DView = ({ geometryData, wallData }) => {
      const mountRef = React.useRef(null);

      React.useEffect(() => {
          if (!mountRef.current) return;
          
          // FIX 1: Provide fallback dimensions to prevent NaN matrix errors on initial mount
          const initialWidth = mountRef.current.clientWidth || window.innerWidth;
          const initialHeight = mountRef.current.clientHeight || 300;

          const scene = new THREE.Scene();
          scene.background = new THREE.Color(0xffffff);

          // Force Z as Up to match 2D cartesian math perfectly
          THREE.Object3D.DefaultUp.set(0, 0, 1);
          const camera = new THREE.PerspectiveCamera(45, initialWidth / initialHeight, 1, 2000);
          camera.position.set(0, -200, 150);

          const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
          // FIX 2: Enable high-DPI rendering so it doesn't look blurry on mobile screens
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setSize(initialWidth, initialHeight);
          mountRef.current.appendChild(renderer.domElement);

          const controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;

          const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
          scene.add(ambientLight);
          const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
          dirLight.position.set(50, -100, 200);
          scene.add(dirLight);

          const group = new THREE.Group();
          scene.add(group);

          // Draw Cabinets
          geometryData.forEach(item => {
              if (item.verts.length < 3) return;
              
              const shape = new THREE.Shape();
              item.verts.forEach((v, i) => {
                  if (i === 0) shape.moveTo(v.x, v.y);
                  else shape.lineTo(v.x, v.y);
              });

              let zBottom = item.zBottom;
              let shapeHeight = item.height;
              
              // Define standard color (bases vs uppers)
              const color = item.isUpper ? 0xfdfdfd : 0xf0f0f0;

              // EXACT FRONT-ONLY TOE KICK
              if (!item.isUpper && Math.abs(zBottom) < 0.1 && item.kickVerts.length > 0) {
                  shapeHeight = item.height - 4; // subtract 4-inch kick height
                  zBottom = 4; // lift the main cabinet body
                  
                  const kickShape = new THREE.Shape();
                  item.kickVerts.forEach((v, i) => {
                      if (i === 0) kickShape.moveTo(v.x, v.y);
                      else kickShape.lineTo(v.x, v.y);
                  });

                  const kickExtrude = { depth: 4, bevelEnabled: false };
                  // MATCH the cabinet color instead of black
                  const kickMat = new THREE.MeshLambertMaterial({ color: color });
                  const kickGeo = new THREE.ExtrudeGeometry(kickShape, kickExtrude);
                  const kickMesh = new THREE.Mesh(kickGeo, kickMat);
                  kickMesh.position.z = 0;
                  group.add(kickMesh);
                  
                  // Add Blueprint outlines to the kick base
                  const kickEdges = new THREE.EdgesGeometry(kickGeo);
                  const kickLine = new THREE.LineSegments(kickEdges, new THREE.LineBasicMaterial({ color: 0x404040, linewidth: 1 }));
                  kickLine.position.z = 0;
                  group.add(kickLine);
              }

              const extrudeSettings = { depth: shapeHeight, bevelEnabled: false };
              const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
              
              const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.95 });
              const mesh = new THREE.Mesh(geometry, material);
              mesh.position.z = zBottom;
              group.add(mesh);

              // Add Edges for Blueprint outline look
              const edges = new THREE.EdgesGeometry(geometry);
              const lineMat = new THREE.LineBasicMaterial({ color: item.isUpper ? 0x8b0000 : 0x404040, linewidth: 1 });
              const line = new THREE.LineSegments(edges, lineMat);
              line.position.z = zBottom;
              group.add(line);
          });

          // Draw Transparent Walls (Mathematically Flat / Zero Thickness)
          wallData.forEach(w => {
              const length = Math.sqrt((w.x2 - w.x1)**2 + (w.y2 - w.y1)**2);
              if (length < 0.1) return;
              const wallHeight = 96;
              
              const geo = new THREE.PlaneGeometry(length, wallHeight);
              geo.rotateX(Math.PI / 2); // Stand plane up
              
              // FIX 3: Added depthWrite: false to fix transparent rendering issues on mobile GPUs
              const mat = new THREE.MeshLambertMaterial({ color: 0x9ca3af, transparent: true, opacity: 0.3, side: THREE.DoubleSide, depthWrite: false });
              const mesh = new THREE.Mesh(geo, mat);
              
              mesh.position.set((w.x1 + w.x2)/2, (w.y1 + w.y2)/2, wallHeight/2);
              mesh.rotation.z = Math.atan2(w.y2 - w.y1, w.x2 - w.x1);
              group.add(mesh);
          });

          // Center Camera View
          if (geometryData.length > 0 || wallData.length > 0) {
              const box = new THREE.Box3().setFromObject(group);
              const center = box.getCenter(new THREE.Vector3());
              const size = box.getSize(new THREE.Vector3());
              const maxDim = Math.max(size.x, size.y, size.z);
              
              controls.target.copy(center);
              camera.position.set(center.x, center.y - maxDim * 1.5, center.z + maxDim);
              controls.update();
          }

          const animate = () => {
              requestAnimationFrame(animate);
              controls.update();
              renderer.render(scene, camera);
          };
          animate();

          // FIX 4: Use ResizeObserver instead of window resize for robust mobile layout tracking
          const resizeObserver = new ResizeObserver(entries => {
              for (let entry of entries) {
                  const { width, height } = entry.contentRect;
                  // Only update if we have a valid height to prevent NaN matrix crashes
                  if (width > 0 && height > 0) {
                      camera.aspect = width / height;
                      camera.updateProjectionMatrix();
                      renderer.setSize(width, height);
                  }
              }
          });
          resizeObserver.observe(mountRef.current);

          return () => {
              resizeObserver.disconnect();
              if (mountRef.current && renderer.domElement) {
                  mountRef.current.removeChild(renderer.domElement);
              }
              renderer.dispose();
          };
      }, [geometryData, wallData]);

      // FIX 5: Added inline touchAction: 'none' to ensure OrbitControls gets clean touch events
      return <div ref={mountRef} style={{ width: '100%', height: '100%', cursor: 'grab', touchAction: 'none' }} />;
  };

  // --- 3. MAIN KITCHEN VISUALIZER COMPONENT ---
  const KitchenVisualizer = ({ code, setCode }) => {
    const { useState, useRef, useMemo, useEffect } = React;
    const [viewBox, setViewBox] = useState({ x: -150, y: -150, width: 300, height: 300 });
    const [sidebarOpen, setSidebarOpen] = useState(false); 
    const [is3D, setIs3D] = useState(false); 
    const [description, setDescription] = useState("");
    
    useEffect(() => {
        if (window.innerWidth > 600) setSidebarOpen(true);
    }, []);

    // API simulation
    useEffect(() => {
        if (!description.trim()) return;
        const timer = setTimeout(async () => {
            try {
                const response = await fetch('https://api-draw.cabinetryexpress.com/api/generate', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: description })
                });
                const data = await response.json();
                if (data.code) setCode(data.code);
            } catch (err) { }
        }, 50);
        return () => clearTimeout(timer);
    }, [description, setCode]);

    const isDragging = useRef(false);
    const lastPos = useRef({ x: 0, y: 0 });
    const svgRef = useRef(null);
    const dynamicFontSize = viewBox.width / 50; 
    const dynamicStroke = viewBox.width / 700; 

    // Parse Data for List
    const organizedData = useMemo(() => {
        const walls = {};
        if (!code) return walls;
        const items = code.replace(/\|\|/g, '\n').replace(/;/g, '\n').split('\n').map((l, i) => {
            const p = l.trim().split('|');
            if (p.length < 8) return null; 
            const c = p[1].toUpperCase();
            const isUpper = (c.startsWith('W') || c.includes('WALL FILLER') || c.startsWith('DCW'));
            return { wall: p[0], code: p[1], idx: i + 1, type: isUpper ? 'upper' : 'base' };
        }).filter(Boolean);
        
        items.forEach(item => {
            if (!walls[item.wall]) walls[item.wall] = { base: [], upper: [] };
            if (item.type === 'base') walls[item.wall].base.push(item);
            else walls[item.wall].upper.push(item);
        });
        return Object.keys(walls).sort().reduce((obj, key) => { obj[key] = walls[key]; return obj; }, {});
    }, [code]);

    // Geometry Processing (Math is pure Y-UP cartesian)
    const { geometry, dimLines, wallLines } = useMemo(() => {
      const items = [];
      const walls_data = [];

      (code || "").replace(/\|\|/g, '\n').replace(/;/g, '\n').split('\n').forEach(l => {
        const p = l.trim().split('|');
        if (p.length >= 8) {
          items.push({ 
            wall: p[0], code: p[1], 
            x1: parseFloat(p[2]), y1: parseFloat(p[3]), zTop: parseFloat(p[4]),
            x2: parseFloat(p[5]), y2: parseFloat(p[6]) 
          });
        } else if (p.length >= 5 && !isNaN(parseFloat(p[1]))) {
          walls_data.push({
            wallRef: p[0],
            x1: parseFloat(p[1]), y1: parseFloat(p[2]),
            x2: parseFloat(p[3]), y2: parseFloat(p[4])
          });
        }
      });
      
      const geo = []; 
      const allSegments = [];
      const dims = []; 
      const walls = [];

      items.forEach((item, idx) => {
        const c = item.code.toUpperCase();
        let depth = 24, stroke = 'black', type = 'std', isUpper = false;
        
        // Identify Tall/Pantry Cabinets specifically
        const isTall = c.startsWith('U') || c.includes('PANTRY') || c.includes('TALL') || c.startsWith('OVEN');

        if (c.startsWith('W') || c.includes('WALL FILLER')) { depth = 12; stroke = 'red'; isUpper = true; }
        else if (c.startsWith('DCW')) { depth = 12; stroke = 'red'; type = 'diag'; isUpper = true; }
        else if (c.startsWith('ERB') || c.startsWith('LSB') || c.startsWith('BBC')) { depth = 24; stroke = 'black'; type = 'L'; }
        
        // Extrude heights
        let height = 34.5; 
        if (isUpper) {
            const match = c.match(/\d+$/);
            if (match && match[0].length === 4) height = parseInt(match[0].slice(2,4));
            else if (match && match[0].length === 2) height = parseInt(match[0]);
            else height = 30; 
        } else if (isTall) {
            // Attempt to grab the height from a typical tall code (e.g. U2484)
            const match = c.match(/\d{2}/g);
            if (match && match.length > 0) height = parseInt(match[match.length - 1]);
            else height = isNaN(item.zTop) ? 84 : item.zTop;
            
            // Failsafe to ensure pantries are actually tall
            if (height < 72) height = isNaN(item.zTop) ? 84 : item.zTop;
        }

        // Logic correctly pushes Tall cabinets' zBottom to 0 (floor) so toe kicks apply natively
        const zTop = isNaN(item.zTop) ? (isUpper ? 84 : (isTall ? height : 34.5)) : item.zTop;
        const zBottom = zTop - height;

        const P1 = {x: item.x1, y: item.y1}, P2 = {x: item.x2, y: item.y2};
        const vec = Vec.sub(P2, P1);
        if (Vec.len(vec) < 0.1) return;
        const u = Vec.norm(vec); 
        const roomVec = { x: u.y, y: -u.x }; 
        
        let verts = [], kickVerts = [], labelPos = {x:0, y:0};
        const kickDepth = 3.0; // 3-inch toe kick inset
        
        const resolveBackDir = (uSeg, bisector) => { const n1 = { x: -uSeg.y, y: uSeg.x }; const n2 = { x: uSeg.y, y: -uSeg.x }; return Vec.dot(n1, bisector) < 0 ? n1 : n2; };
        const addSeg = (s, e, normal) => { allSegments.push({ start: s, end: e, normal, isUpper, wallRef: item.wall }); };
        
        if (type === 'std') {
           const F1 = Vec.add(P1, Vec.scale(roomVec, depth)); const F2 = Vec.add(P2, Vec.scale(roomVec, depth));
           verts = [P1, P2, F2, F1]; const labelShift = isUpper ? 0.5 : 0.9;
           labelPos = Vec.add(Vec.mid(P1, P2), Vec.scale(roomVec, depth * labelShift)); addSeg(P1, P2, Vec.scale(roomVec, -1));
           
           // Generate flush sides, inset front for toe kick
           if (!isUpper) {
               const kDist = depth - kickDepth;
               const K1 = Vec.add(P1, Vec.scale(roomVec, kDist));
               const K2 = Vec.add(P2, Vec.scale(roomVec, kDist));
               kickVerts = [P1, P2, K2, K1];
           }
        } else if (type === 'L' || type === 'diag') {
           const C1 = {x:P1.x, y:P2.y}, C2 = {x:P2.x, y:P1.y}; 
           const rot1 = (C1.x - P1.x) * (P2.y - C1.y) - (C1.y - P1.y) * (P2.x - C1.x); 
           const C = rot1 < 0 ? C1 : C2;
           
           const u1 = Vec.norm(Vec.sub(P1, C)), u2 = Vec.norm(Vec.sub(P2, C)); const bisector = Vec.norm(Vec.add(u1, u2));
           const F1 = Vec.add(P1, Vec.scale(u2, depth)), F2 = Vec.add(P2, Vec.scale(u1, depth));
           
           if(type === 'L') { 
               const Inner = Vec.add(C, Vec.add(Vec.scale(u1, depth), Vec.scale(u2, depth))); 
               verts = [P1, C, P2, F2, Inner, F1]; 
               
               if (!isUpper) {
                   const kDist = depth - kickDepth;
                   const K_F1 = Vec.add(P1, Vec.scale(u2, kDist));
                   const K_F2 = Vec.add(P2, Vec.scale(u1, kDist));
                   const K_Inner = Vec.add(C, Vec.add(Vec.scale(u1, kDist), Vec.scale(u2, kDist)));
                   kickVerts = [P1, C, P2, K_F2, K_Inner, K_F1];
               }
           } else { 
               verts = [P1, C, P2, F2, F1]; 
               
               if (!isUpper) {
                   const kDist = depth - kickDepth;
                   const K_F1 = Vec.add(C, Vec.scale(Vec.norm(Vec.sub(F1, C)), kDist));
                   const K_F2 = Vec.add(C, Vec.scale(Vec.norm(Vec.sub(F2, C)), kDist));
                   kickVerts = [P1, C, P2, K_F2, K_F1];
               }
           }
           const labelShift = isUpper ? 0.8 : 1.4; labelPos = Vec.add(C, Vec.scale(bisector, depth * labelShift));
           addSeg(C, P1, resolveBackDir(Vec.scale(u1, -1), bisector));
           addSeg(C, P2, resolveBackDir(Vec.scale(u2, -1), bisector));
        }

        geo.push({ id: idx, verts, labelPos, code: item.code, stroke, idx: idx+1, isUpper, height, zTop, zBottom, kickVerts });
      });

      const wallGroups = [];
      allSegments.forEach(seg => {
          const segVec = Vec.sub(seg.end, seg.start);
          if (Vec.len(segVec) < 0.1) return;
          const normal = Vec.norm(seg.normal);
          const dist = Vec.dot(seg.start, normal);
          let match = wallGroups.find(w => Math.abs(Vec.dot(w.normal, normal)) > 0.99 && Math.abs(w.dist - dist) < 1.0);
          if (match) match.segments.push(seg);
          else wallGroups.push({ normal, dist, segments: [seg], ref: seg.wallRef });
      });

      if (walls_data.length === 0) {
          wallGroups.forEach(wall => {
              const axis = { x: -wall.normal.y, y: wall.normal.x }; 
              const proj = p => Vec.dot(p, axis);
              let minT = Infinity, maxT = -Infinity, pStart = null, pEnd = null;
              wall.segments.forEach(s => { 
                 [s.start, s.end].forEach(p => { 
                     const t = proj(p); 
                     if(t < minT) { minT = t; pStart = p; } 
                     if(t > maxT) { maxT = t; pEnd = p; } 
                 }); 
              });
              if(pStart && pEnd && Vec.dist(pStart, pEnd) > 1.0) { 
                  walls_data.push({ wallRef: wall.ref, x1: pStart.x, y1: pStart.y, x2: pEnd.x, y2: pEnd.y });
              }
          });
      }

      walls_data.forEach(w => {
          const p1 = { x: w.x1, y: w.y1 }, p2 = { x: w.x2, y: w.y2 };
          walls.push({ p1, p2, x1: w.x1, y1: w.y1, x2: w.x2, y2: w.y2 });
          const wVec = Vec.sub(p2, p1);
          if (Vec.len(wVec) < 0.1) return;
          const wDir = Vec.norm(wVec);
          let normal = { x: -wDir.y, y: wDir.x }; 
          for (const group of wallGroups) {
              if (Math.abs(Vec.dot(wDir, group.normal)) > 0.1) continue; 
              const cabPt = group.segments[0].start;
              const vecToWall = Vec.sub(p1, cabPt);
              if (Math.abs(Vec.dot(vecToWall, group.normal)) < 5.0) { normal = group.normal; break; }
          }
          dims.push({ p1, p2, offset: 22, color: 'blue', text: formatDim(Vec.dist(p1, p2)), normal, label: w.wallRef });
      });

      wallGroups.forEach(wall => {
          let globalStart = null, globalEnd = null;
          const axis = { x: -wall.normal.y, y: wall.normal.x }; 
          const proj = p => Vec.dot(p, axis);
          let matchedWall = walls_data.find(w => {
              const w1 = {x: w.x1, y: w.y1}, w2 = {x: w.x2, y: w.y2};
              const wVec = Vec.sub(w2, w1);
              if (Vec.len(wVec) < 0.1) return false;
              if (Math.abs(Vec.dot(Vec.norm(wVec), wall.normal)) > 0.1) return false;
              return Math.abs(Vec.dot(Vec.sub(w1, wall.segments[0].start), wall.normal)) < 5.0; 
          });

          if (matchedWall) {
              const pts = [ {x: matchedWall.x1, y: matchedWall.y1}, {x: matchedWall.x2, y: matchedWall.y2} ];
              const proj0 = proj(pts[0]), proj1 = proj(pts[1]);
              if (proj0 < proj1) { globalStart = pts[0]; globalEnd = pts[1]; }
              else { globalStart = pts[1]; globalEnd = pts[0]; }
          }

          const makeChain = (isUp, color, offset) => {
             const chainSegs = wall.segments.filter(s => s.isUpper === isUp); 
             if (!chainSegs.length) return;
             const items = chainSegs.map(s => { 
                 const t1 = proj(s.start), t2 = proj(s.end); 
                 return { min: Math.min(t1,t2), max: Math.max(t1,t2), p_min: t1<t2?s.start:s.end, p_max: t1<t2?s.end:s.start }; 
             });
             items.sort((a,b) => a.min - b.min);
             let startPt = globalStart || items[0].p_min;
             let endPt = globalEnd || items[items.length-1].p_max;

             const startGap = Vec.dist(startPt, items[0].p_min); 
             if (startGap > 0.5) dims.push({ p1: startPt, p2: items[0].p_min, offset, color, text: formatDim(startGap), normal: wall.normal, isGap: true }); 
             for(let i=0; i<items.length; i++) {
                 const curr = items[i]; 
                 dims.push({ p1: curr.p_min, p2: curr.p_max, offset, color, text: formatDim(Vec.dist(curr.p_min, curr.p_max)), normal: wall.normal });
                 if(i < items.length-1) { 
                     const next = items[i+1]; const gap = Vec.dist(curr.p_max, next.p_min); 
                     if(gap > 0.5) dims.push({ p1: curr.p_max, p2: next.p_min, offset, color, text: formatDim(gap), normal: wall.normal, isGap: true }); 
                 }
             }
             const endGap = Vec.dist(items[items.length-1].p_max, endPt); 
             if (endGap > 0.5) dims.push({ p1: items[items.length-1].p_max, p2: endPt, offset, color, text: formatDim(endGap), normal: wall.normal, isGap: true }); 
          };
          makeChain(true, 'red', 10); 
          makeChain(false, 'black', 16);
      });

      return { geometry: geo, dimLines: dims, wallLines: walls };
    }, [code]);

    // ViewBox mapping (translating Cartesian Y mapping to Screen Y safely)
    useEffect(() => {
        if (!geometry.length && !wallLines.length) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        geometry.forEach(g => { g.verts.forEach(v => { if (v.x < minX) minX = v.x; if (v.x > maxX) maxX = v.x; if (v.y < minY) minY = v.y; if (v.y > maxY) maxY = v.y; }); });
        wallLines.forEach(w => { [w.p1, w.p2].forEach(v => { if (v.x < minX) minX = v.x; if (v.x > maxX) maxX = v.x; if (v.y < minY) minY = v.y; if (v.y > maxY) maxY = v.y; }); });
        const w = maxX - minX; const h = maxY - minY; if (w === 0 || h === 0) return;
        const padding = Math.max(w, h) * 0.50; 
        
        // Key fix: y starts at negative Max Y for SVG plotting
        setViewBox({ x: minX - padding, y: -maxY - padding, width: w + (padding * 2), height: h + (padding * 2) });
    }, [geometry, wallLines]);

    const handleWheel = (e) => { e.preventDefault(); const s = e.deltaY > 0 ? 1.1 : 0.9; setViewBox(v => ({ x: v.x-(v.width*(s-1))/2, y: v.y-(v.height*(s-1))/2, width: v.width*s, height: v.height*s })); };
    const handleStart = (x, y) => { isDragging.current = true; lastPos.current = { x, y }; };
    const handleEnd = () => { isDragging.current = false; };
    const handleMove = (x, y) => { if (!isDragging.current) return; const r = svgRef.current.getBoundingClientRect(); const scaleX = viewBox.width / r.width; const scaleY = viewBox.height / r.height; const dx = (x - lastPos.current.x) * scaleX; const dy = (y - lastPos.current.y) * scaleY; setViewBox(v => ({...v, x: v.x - dx, y: v.y - dy})); lastPos.current = { x, y }; };

    return (
      <>
      <div className={`sidebar ${sidebarOpen ? 'open' : 'closed'}`}>
         <div className="sidebar-mobile-nav">
            <button className="sidebar-back-btn" onClick={() => setSidebarOpen(false)}>◀ Back to Drawing</button>
            <div className="sidebar-input-group">
                <textarea value={description} onChange={e => setDescription(e.target.value)} placeholder="Describe Kitchen..." rows="3" />
            </div>
         </div>
         <div className="sidebar-header">Cabinet List</div>
         <div className="sidebar-content">
            {Object.keys(organizedData).map(wallKey => (
                <div key={wallKey} className="wall-group">
                    <div className="wall-title"><span className="wall-badge">Wall {wallKey}</span></div>
                    {organizedData[wallKey].base.length > 0 && (
                        <>
                            <div className="cat-title">Base Cabinets</div>
                            {organizedData[wallKey].base.map((item, i) => (
                                <div key={i} className="cab-item"><span><span className="cab-idx">({item.idx})</span> {item.code}</span></div>
                            ))}
                        </>
                    )}
                    {organizedData[wallKey].upper.length > 0 && (
                        <>
                            <div className="cat-title">Wall Cabinets</div>
                            {organizedData[wallKey].upper.map((item, i) => (
                                <div key={i} className="cab-item"><span><span className="cab-idx">({item.idx})</span> {item.code}</span></div>
                            ))}
                        </>
                    )}
                </div>
            ))}
         </div>
      </div>

      <div id="kitchen-app-container">
        <div className="control-panel">
          <div className="input-row primary">
             <div className="left-controls">
                 <button className="toggle-sidebar" onClick={() => setSidebarOpen(!sidebarOpen)} title="Toggle List View">
                    {sidebarOpen ? '◀ Close List' : '☰ List View'}
                 </button>
                 <button className="toggle-view" onClick={() => setIs3D(!is3D)}>
                     {is3D ? 'Switch to 2D' : 'Switch to 3D'}
                 </button>
             </div>
             
             <div className="input-label">Describe Kitchen:</div>
             <textarea value={description} onChange={e => setDescription(e.target.value)} placeholder="e.g.12 inch base, sink 36, pull out trash 18,lazy susan..." rows="3" />
          </div>
          <div className="input-row" style={{ display: 'none' }}>
             <input value={code} onChange={e => setCode(e.target.value)} />
          </div>
        </div>

        <div className={`viewport ${is3D ? 'mode-3d' : 'mode-2d'}`}>
          {is3D ? (
              <Kitchen3DView geometryData={geometry} wallData={wallLines} />
          ) : (
              <svg ref={svgRef} viewBox={`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`} 
                   onWheel={handleWheel} 
                   onMouseDown={(e)=>handleStart(e.clientX, e.clientY)} 
                   onMouseMove={(e)=>handleMove(e.clientX, e.clientY)} 
                   onMouseUp={handleEnd} onMouseLeave={handleEnd}
                   onTouchStart={(e)=>{if(e.touches.length===1)handleStart(e.touches[0].clientX, e.touches[0].clientY)}}
                   onTouchMove={(e)=>{if(e.touches.length===1)handleMove(e.touches[0].clientX, e.touches[0].clientY)}}
                   onTouchEnd={handleEnd}>
                 {geometry.map(g => ( 
                   <g key={g.id}> 
                     {/* Y is inverted just for SVG Display */}
                     <polygon points={g.verts.map(v=>`${v.x},${-v.y}`).join(' ')} fill="white" stroke={g.stroke} strokeWidth={dynamicStroke} /> 
                     <text x={g.labelPos.x} y={-g.labelPos.y} fontSize={dynamicFontSize} textAnchor="middle" fontWeight="bold">
                       <tspan fill="green">({g.idx}) </tspan><tspan fill={g.stroke}>{g.code}</tspan>
                     </text> 
                   </g> 
                 ))}
                 {wallLines.map((w, i) => ( <line key={`wall-${i}`} x1={w.p1.x} y1={-w.p1.y} x2={w.p2.x} y2={-w.p2.y} stroke="blue" strokeWidth={dynamicStroke * 2.5} /> ))}
                 {dimLines.map((d, i) => { 
                     const offVec = Vec.scale(d.normal, d.offset); const p1 = Vec.add(d.p1, offVec), p2 = Vec.add(d.p2, offVec); 
                     const mid = Vec.mid(p1, p2); const delta = Vec.sub(p2, p1); 
                     let ang = Math.atan2(-delta.y, delta.x) * 180 / Math.PI; 
                     if(ang > 90 || ang < -90) ang += 180; 
                     const txtPos = Vec.add(mid, Vec.scale(d.normal, 2.5)); 
                     return ( 
                         <g key={i}> 
                           <line x1={p1.x} y1={-p1.y} x2={p2.x} y2={-p2.y} stroke={d.color} strokeWidth={d.isGap?dynamicStroke*0.8:dynamicStroke*1.2} strokeDasharray={d.isGap?"1,1":""} /> 
                           <line x1={p1.x-d.normal.x*1.5} y1={-p1.y+d.normal.y*1.5} x2={p1.x+d.normal.x*1.5} y2={-p1.y-d.normal.y*1.5} stroke={d.color} strokeWidth={dynamicStroke*1.2} /> 
                           <line x1={p2.x-d.normal.x*1.5} y1={-p2.y+d.normal.y*1.5} x2={p2.x+d.normal.x*1.5} y2={-p2.y-d.normal.y*1.5} stroke={d.color} strokeWidth={dynamicStroke*1.2} /> 
                           <line x1={d.p1.x} y1={-d.p1.y} x2={p1.x} y2={-p1.y} stroke={d.color} strokeWidth={dynamicStroke*0.4} opacity="0.3" strokeDasharray="1,2" /> 
                           <line x1={d.p2.x} y1={-d.p2.y} x2={p2.x} y2={-p2.y} stroke={d.color} strokeWidth={dynamicStroke*0.4} opacity="0.3" strokeDasharray="1,2" /> 
                           <text x={txtPos.x} y={-txtPos.y} fill={d.color} fontSize={dynamicFontSize * 1.2} textAnchor="middle" transform={`rotate(${ang}, ${txtPos.x}, ${-txtPos.y})`}> 
                             {d.text} {d.label && <tspan fill="green" fontWeight="bold" fontSize={dynamicFontSize * 1.5}> {d.label}</tspan>} 
                           </text> 
                         </g> 
                     ); 
                 })}
              </svg>
          )}
          <div className="status-overlay">
              {is3D ? "Left Click: Rotate • Right Click: Pan • Scroll: Zoom" : "Scroll to Zoom • Drag to Pan"}
          </div>
        </div>
      </div>
      </>
    );
  };

  const App = () => {
    // Loaded with some default demo data (including a pantry!)
    const demoData = "Wall A|B24|0|0|34.5|24|0\nWall A|R30|24|0|34.5|54|0\nWall A|U2484 PANTRY|54|0|84|78|0\nWall A|W2430|0|0|84|24|0";
    const [kitchenCode, setKitchenCode] = React.useState(demoData);
    return <KitchenVisualizer code={kitchenCode} setCode={setKitchenCode} />;
  };

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
</script>

</body>
</html>
